{"version":3,"file":"build/444-987d2d38d511226786fd.js","mappings":"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","sources":["file:///home/runner/work/bemuse/bemuse/bemuse/src/app/interactors/getLR2Score.js","file:///home/runner/work/bemuse/bemuse/bemuse/src/custom-folder/index.ts","file:///home/runner/work/bemuse/bemuse/bemuse/src/custom-song-loader/index.ts","file:///home/runner/work/bemuse/bemuse/bemuse/src/online/data-store.ts","file:///home/runner/work/bemuse/bemuse/bemuse/src/rules/mapping-mode.ts","file:///home/runner/work/bemuse/bemuse/bemuse/src/online/level.ts","file:///home/runner/work/bemuse/bemuse/bemuse/src/online/id.js","file:///home/runner/work/bemuse/bemuse/bemuse/src/online/BatchedFetcher.ts","file:///home/runner/work/bemuse/bemuse/bemuse/src/online/index.ts","file:///home/runner/work/bemuse/bemuse/bemuse/src/online/operations.ts","file:///home/runner/work/bemuse/bemuse/bemuse/src/online/queryKeys.ts","file:///home/runner/work/bemuse/bemuse/bemuse/src/online/scoreboard-system/createFakeScoreboardClient.ts","file:///home/runner/work/bemuse/bemuse/bemuse/src/online/scoreboard-system/createNextScoreboardClient.ts","file:///home/runner/work/bemuse/bemuse/bemuse/src/online/scoreboard-system/OnlineService.ts","file:///home/runner/work/bemuse/bemuse/bemuse/src/react-query/index.ts"],"sourcesContent":["// Calculates the score as if it was computed by LR2.\n//\n// - `deltas` The array representing the player’s delta offsets in **seconds**.\n// - `timegates` A 2-tuple containing **millisecond values**:\n//     - `[0]` The timegate for PGREAT judgment.\n//     - `[1]` The timegate for GREAT judgment.\n//\n// This module is implemented so that we can compare the difficulty\n// of grading system in Bemuse to Lunatic Rave 2’s.\n//\nexport function getLR2Score(deltas, [meticulousWindow, preciseWindow]) {\n  let sum = 0\n  for (const delta of deltas) {\n    const difference = Math.abs(delta) * 1000\n    if (difference < meticulousWindow) sum += 1\n    if (difference < preciseWindow) sum += 1\n  }\n  return sum\n}\n\nexport default getLR2Score\n","import _ from 'lodash'\nimport { get, set, del } from 'idb-keyval'\nimport pMemoize from 'p-memoize'\nimport {\n  CustomFolderChartFile,\n  CustomFolderFolderEntry,\n  CustomFolderSong,\n  CustomFolderState,\n} from './types'\nimport { loadSongFromResources } from 'bemuse/custom-song-loader'\nimport { ICustomSongResources, IResources } from 'bemuse/resources/types'\nimport { FileResource } from 'bemuse/resources/custom-song-resources'\nimport { Song } from 'bemuse/collection-model/types'\n\nexport interface CustomFolderContext {\n  get: (key: string) => Promise<CustomFolderState | undefined>\n  set: (key: string, value: CustomFolderState) => Promise<void>\n  del: (key: string) => Promise<void>\n}\n\nexport class CustomFolderContextImpl implements CustomFolderContext {\n  get = get\n  set = set\n  del = del\n}\n\nconst CUSTOM_FOLDER_KEYVAL_KEY = 'custom-folder-1'\n\nexport async function setCustomFolder(\n  context: CustomFolderContext,\n  folder: FileSystemDirectoryHandle\n) {\n  await context.set(CUSTOM_FOLDER_KEYVAL_KEY, {\n    handle: folder,\n  })\n}\n\nexport async function clearCustomFolder(context: CustomFolderContext) {\n  await context.del(CUSTOM_FOLDER_KEYVAL_KEY)\n}\n\nexport async function getCustomFolderState(context: CustomFolderContext) {\n  return context.get(CUSTOM_FOLDER_KEYVAL_KEY)\n}\n\nexport const getDefaultCustomFolderContext = _.once(\n  () => new CustomFolderContextImpl()\n)\n\nexport type CustomFolderScanIO = {\n  log: (message: string) => void\n  setStatus: (message: string) => void\n  updateState: (state: CustomFolderState) => void\n}\n\nexport async function scanFolder(\n  context: CustomFolderContext,\n  io: CustomFolderScanIO\n) {\n  let state = await getCustomFolderState(context)\n  const { log, setStatus, updateState } = io\n  for (let i = 1; ; i++) {\n    log(`Iteration #${i} start`)\n    const result = await scanIteration(state, io)\n\n    // If there is nothing to be done in the very first iteration, let’s rescan the folder for new chart files.\n    if (!result && i === 1) {\n      state = { ...state, chartFilesScanned: false }\n      continue\n    }\n\n    if (!result) {\n      break\n    }\n    if (result.nextState) {\n      state = result.nextState\n      updateState(state)\n      setStatus(`Saving state (iteration #${i})`)\n      await context.set(CUSTOM_FOLDER_KEYVAL_KEY, state)\n    }\n    if (!result.moreIterationsNeeded) {\n      break\n    }\n  }\n  setStatus('Done scanning.')\n}\n\nasync function scanIteration(\n  inputState: CustomFolderState | undefined,\n  io: CustomFolderScanIO\n): Promise<ScanIterationResult | undefined> {\n  const result = await checkFolderStateAndPermissions(inputState, io)\n  if (!result) {\n    return\n  }\n  const { state, handle } = result\n\n  if (!state.chartFilesScanned) {\n    return scanAllChartFiles(state, handle, io)\n  }\n\n  if ((state?.foldersToUpdate?.length ?? 0) > 0) {\n    return updateFolders(state, handle, io)\n  }\n\n  if ((state?.foldersToRemove?.length ?? 0) > 0) {\n    return removeFolders(state, handle, io)\n  }\n}\n\nasync function checkFolderStateAndPermissions(\n  state: CustomFolderState | undefined,\n  io: CustomFolderScanIO\n): Promise<\n  | {\n      state: CustomFolderState\n      handle: FileSystemDirectoryHandle\n    }\n  | undefined\n> {\n  const { log, setStatus } = io\n  if (!state) {\n    const message = 'No custom folder set.'\n    log(message)\n    setStatus(message)\n    return\n  }\n\n  const { handle } = state\n  if (!handle) {\n    const message = 'No folder selected.'\n    log(message)\n    setStatus(message)\n    return\n  }\n\n  let permission = await handle.queryPermission({ mode: 'read' })\n  if (permission === 'prompt') {\n    setStatus('Waiting for permission — please grant access to the folder.')\n    permission = await handle.requestPermission({ mode: 'read' })\n  }\n  if (permission !== 'granted') {\n    log('Unable to read the folder due to lack of permissions.')\n    setStatus('Unable to read the folder due to lack of permissions.')\n    return\n  }\n\n  return { state, handle }\n}\n\nasync function scanAllChartFiles(\n  state: CustomFolderState,\n  handle: FileSystemDirectoryHandle,\n  io: CustomFolderScanIO\n): Promise<ScanIterationResult | undefined> {\n  const { log, setStatus } = io\n  const chartFileScanner = new ChartFileScanner(state.chartFiles, true)\n  await searchForChartFiles(handle, chartFileScanner, io)\n\n  const newChartFiles = chartFileScanner.getNewChartFiles()\n  const foldersToUpdate = chartFileScanner.getFoldersToUpdate()\n  const foldersToRemove = chartFileScanner.getFoldersToRemove()\n  const message =\n    'Scanning done. ' +\n    [\n      `Charts: ${newChartFiles.length}`,\n      `Folders: ${chartFileScanner.getFolderCount()}`,\n      `Folders to update: ${foldersToUpdate.length}`,\n      `Folders to remove: ${foldersToRemove.length}`,\n    ].join('; ')\n  log(message)\n  setStatus(message)\n\n  return {\n    nextState: {\n      ...state,\n      chartFiles: newChartFiles,\n      chartFilesScanned: true,\n      foldersToUpdate,\n      foldersToRemove,\n    },\n    moreIterationsNeeded: true,\n  }\n}\n\nasync function searchForChartFiles(\n  directoryHandle: FileSystemDirectoryHandle,\n  chartFileScanner: ChartFileScanner,\n  io: CustomFolderScanIO,\n  parentPath: string[] = []\n): Promise<void> {\n  let entriesRead = 0\n  const { log, setStatus } = io\n  for await (const [name, handle] of directoryHandle) {\n    const childPath = [...parentPath, name]\n    try {\n      if (handle.kind === 'directory') {\n        await searchForChartFiles(handle, chartFileScanner, io, childPath)\n      } else if (/\\.(bms|bme|bml|bmson)$/i.test(name)) {\n        const fileHandle = handle\n        await chartFileScanner.addPath(childPath, {\n          getModifiedDate: async () => {\n            const file = await fileHandle.getFile()\n            return file.lastModified\n          },\n        })\n      }\n    } catch (error) {\n      log(`Error while processing ${childPath.join('/')}: ${error}`)\n      console.error(error)\n    }\n    entriesRead++\n    const childPathStr = formatPath(childPath)\n    setStatus(\n      `Scanning for chart files. ${entriesRead} entries read. Just processed: ${childPathStr}`\n    )\n  }\n}\n\nasync function updateFolders(\n  state: CustomFolderState,\n  handle: FileSystemDirectoryHandle,\n  io: CustomFolderScanIO\n): Promise<ScanIterationResult | undefined> {\n  const { log, setStatus } = io\n  if ((state?.foldersToUpdate?.length || 0) > 0) {\n    const foldersToUpdate = [...state.foldersToUpdate!]\n    const n = foldersToUpdate.length\n    const songsToSave: CustomFolderSong[] = []\n    const updatedPathSet = new Set<string>()\n    const deadline = Date.now() + 5000\n\n    for (const [i, folder] of foldersToUpdate.entries()) {\n      updatedPathSet.add(JSON.stringify(folder.path))\n\n      const pathStr = formatPath(folder.path)\n      const remaining = n - i\n      log(`Updating folder “${pathStr}” (${remaining} remaining)`)\n      const statusPrefix = `Folder “${pathStr}” (${remaining} remaining)`\n      setStatus(statusPrefix)\n\n      const resources = await getResourcesForFolder(\n        handle,\n        folder.path,\n        state.chartFiles || []\n      )\n      const { resources: _unused, ...song } = await loadSongFromResources(\n        resources,\n        {\n          onMessage: (text) => {\n            log(text)\n            setStatus(`${statusPrefix} ${text}`)\n          },\n        }\n      )\n      if (song.charts.length > 0) {\n        songsToSave.push({\n          path: folder.path,\n          song,\n        })\n      }\n      if (Date.now() > deadline) {\n        break\n      }\n    }\n\n    const songsToSavePathSet = new Set(\n      songsToSave.map((song) => JSON.stringify(song.path))\n    )\n    const newSongs = [\n      ...(state.songs || []).filter(\n        (song) => !songsToSavePathSet.has(JSON.stringify(song.path))\n      ),\n      ...songsToSave,\n    ]\n    const newFoldersToUpdate = foldersToUpdate.filter(\n      (folder) => !updatedPathSet.has(JSON.stringify(folder.path))\n    )\n    return {\n      nextState: {\n        ...state,\n        foldersToUpdate: newFoldersToUpdate,\n        songs: newSongs,\n      },\n      moreIterationsNeeded: true,\n    }\n  }\n}\n\nasync function removeFolders(\n  state: CustomFolderState,\n  handle: FileSystemDirectoryHandle,\n  io: CustomFolderScanIO\n): Promise<ScanIterationResult | undefined> {\n  const { log, setStatus } = io\n\n  if ((state.foldersToRemove?.length ?? 0) > 0) {\n    let remainingSongs = state.songs || []\n    const foldersToRemove = [...state.foldersToRemove!]\n    const n = foldersToRemove.length\n    const removedPathSet = new Set<string>()\n    const deadline = Date.now() + 5000\n\n    for (const [i, folder] of foldersToRemove.entries()) {\n      removedPathSet.add(JSON.stringify(folder.path))\n\n      const pathStr = formatPath(folder.path)\n      const remaining = n - i\n      log(`Removing folder “${pathStr}” (${remaining} remaining)`)\n      const statusPrefix = `Folder “${pathStr}” (${remaining} remaining)`\n      setStatus(statusPrefix)\n\n      remainingSongs = remainingSongs.filter((song) => {\n        return !song.path.includes(pathStr)\n      })\n\n      if (Date.now() > deadline) break\n    }\n\n    const newFoldersToRemove = foldersToRemove.filter(\n      (folder) => !removedPathSet.has(JSON.stringify(folder.path))\n    )\n    return {\n      nextState: {\n        ...state,\n        foldersToRemove: newFoldersToRemove,\n        songs: remainingSongs,\n      },\n      moreIterationsNeeded: true,\n    }\n  }\n}\n\nasync function getResourcesForFolder(\n  rootFolderHandle: FileSystemDirectoryHandle,\n  path: string[],\n  chartFiles: CustomFolderChartFile[]\n): Promise<ICustomSongResources> {\n  const folderHandle = await getFolderHandleByPath(rootFolderHandle, path)\n  const files = chartFiles.filter(\n    (file) =>\n      file.path.length === path.length + 1 &&\n      path.every((p, i) => p === file.path[i])\n  )\n  return {\n    fileList: Promise.resolve(\n      files.map((file) => file.path[file.path.length - 1])\n    ),\n    async file(name) {\n      const fileHandle = await folderHandle.getFileHandle(name)\n      const file = await fileHandle.getFile()\n      return new FileResource(file)\n    },\n  }\n}\n\nasync function getFolderHandleByPath(\n  rootFolderHandle: FileSystemDirectoryHandle,\n  path: string[]\n): Promise<FileSystemDirectoryHandle> {\n  let handle = rootFolderHandle\n  for (const name of path) {\n    handle = await handle.getDirectoryHandle(name)\n  }\n  return handle\n}\n\ntype ScanIterationResult = {\n  nextState?: CustomFolderState\n  moreIterationsNeeded: boolean\n}\n\nclass ChartFileScanner {\n  private existingMap: Map<string, CustomFolderChartFile>\n  private existingFolderSet: Set<string>\n  private foundFolderSet = new Set<string>()\n  private updatedFolderSet = new Set<string>()\n  private newChartFiles: CustomFolderChartFile[] = []\n  private changedPaths: { path: string[]; lastModified: number }[] = []\n\n  constructor(\n    private previous: CustomFolderState['chartFiles'] = [],\n    private fast = false\n  ) {\n    this.existingMap = new Map(\n      _.map(this.previous, (file) => [JSON.stringify(file.path), file])\n    )\n    this.existingFolderSet = new Set(\n      _.map(this.previous, (file) => JSON.stringify(file.path.slice(0, -1)))\n    )\n  }\n\n  async addPath(\n    childPath: string[],\n    io: {\n      getModifiedDate: () => Promise<number>\n    }\n  ) {\n    const key = JSON.stringify(childPath)\n    const folderKey = JSON.stringify(childPath.slice(0, -1))\n    const existing = this.existingMap.get(key)\n    this.foundFolderSet.add(folderKey)\n    if (existing) {\n      if (!this.fast) {\n        const lastModified = await io.getModifiedDate()\n        if (lastModified > existing.lastModified) {\n          this.changedPaths.push({ path: childPath, lastModified })\n          this.newChartFiles.push({ path: childPath, lastModified })\n          this.updatedFolderSet.add(folderKey)\n        } else {\n          this.newChartFiles.push(existing)\n        }\n      } else {\n        this.newChartFiles.push(existing)\n      }\n    } else {\n      const lastModified = await io.getModifiedDate()\n      this.changedPaths.push({ path: childPath, lastModified })\n      this.newChartFiles.push({ path: childPath, lastModified })\n      this.updatedFolderSet.add(folderKey)\n    }\n  }\n\n  getNewChartFiles() {\n    return this.newChartFiles\n  }\n\n  getFoldersToUpdate(): CustomFolderFolderEntry[] {\n    return [...this.updatedFolderSet].map((folderKey) => ({\n      path: JSON.parse(folderKey) as string[],\n    }))\n  }\n\n  getFoldersToRemove(): CustomFolderFolderEntry[] {\n    return [...this.existingFolderSet]\n      .filter((folderKey) => !this.foundFolderSet.has(folderKey))\n      .map((folderKey) => ({\n        path: JSON.parse(folderKey) as string[],\n      }))\n  }\n\n  getFolderCount() {\n    return this.foundFolderSet.size\n  }\n}\nfunction formatPath(childPath: string[]) {\n  return childPath.join('¥')\n}\n\nexport async function getSongsFromCustomFolders(\n  context: CustomFolderContext\n): Promise<Song[]> {\n  const state = await getCustomFolderState(context)\n  if (!state || !state.handle) {\n    return []\n  }\n\n  const customFolderSongs = state.songs || []\n  const resourceFactory = new CustomFolderResourceFactory(state.handle)\n  const out: Song[] = []\n  for (const [i, customFolderSong] of customFolderSongs.entries()) {\n    try {\n      const resources = resourceFactory.getResources(customFolderSong.path)\n      out.push({\n        ...customFolderSong.song,\n        resources,\n        custom: true,\n        id: `__custom_${i}`,\n      })\n    } catch (e) {\n      console.error(e)\n    }\n  }\n  return out\n}\n\nclass CustomFolderResourceFactory {\n  constructor(private rootFolderHandle: FileSystemDirectoryHandle) {}\n  getGrant = pMemoize(async () => {\n    const handle = this.rootFolderHandle\n    let permission = await handle.queryPermission({ mode: 'read' })\n    if (permission === 'prompt') {\n      permission = await handle.requestPermission({ mode: 'read' })\n    }\n    if (permission !== 'granted') {\n      throw new Error('Permission has not been granted')\n    }\n    return permission\n  })\n\n  getResources(path: string[]): IResources {\n    const getFolderHandle = pMemoize(async () => {\n      await this.getGrant()\n      return getFolderHandleByPath(this.rootFolderHandle, path)\n    })\n    return {\n      async file(name) {\n        const folder = await getFolderHandle()\n        const fileHandle = await folder.getFileHandle(name)\n        const file = await fileHandle.getFile()\n        return new FileResource(file)\n      },\n    }\n  }\n}\n","import { ICustomSongResources } from 'bemuse/resources/types'\nimport { Song } from 'bemuse/collection-model/types'\n\n/* eslint import/no-webpack-loader-syntax: off */\nexport function loadSongFromResources(\n  resources: ICustomSongResources,\n  options: LoadSongOptions = {}\n) {\n  const onMessage = options.onMessage || (() => {})\n  if (resources.setLoggingFunction) {\n    resources.setLoggingFunction(onMessage)\n  }\n  return resources.fileList\n    .then((fileList) => {\n      return loadFromFileList(fileList)\n    })\n    .then((song) => {\n      song.resources = resources\n      return song\n    })\n\n  function loadFromFileList(fileList: string[]) {\n    if (fileList.includes('bemuse-song.json')) {\n      return loadFromBemuseSongJson()\n    } else {\n      const bmsFileList = fileList.filter((filename) =>\n        /\\.(bms|bme|bml|bmson)$/i.test(filename)\n      )\n      return loadFromBmsFileList(bmsFileList)\n    }\n  }\n\n  async function loadFromBemuseSongJson() {\n    onMessage('\"bemuse-song.json\" found...')\n    const file = await resources.file('bemuse-song.json')\n    const data = await file.read()\n    const text = await new Blob([data]).text()\n    const song = JSON.parse(text) as Song\n    return song\n  }\n\n  async function loadFromBmsFileList(bmsFileList: string[]) {\n    onMessage(bmsFileList.length + ' file(s) found. Reading them...')\n    const files = await Promise.all(\n      bmsFileList.map(async (filename) => {\n        const start = Date.now()\n        const file = await resources.file(filename)\n        const data = await file.read()\n        const elapsed = Date.now() - start\n        if (elapsed > 1000) onMessage('Read: ' + filename)\n        return {\n          name: filename,\n          data: data,\n        }\n      })\n    )\n    const song = await new Promise<Song>((resolve, reject) => {\n      const worker = new Worker(\n        // @ts-ignore\n        new URL('./song-loader.worker.js', import.meta.url)\n      )\n      worker.onmessage = function ({ data }) {\n        if (data.type === 'result') {\n          resolve(data.song)\n          worker.terminate()\n        } else if (data.type === 'started') {\n          onMessage('Analyzing BMS files...')\n        } else if (data.type === 'progress') {\n          onMessage(\n            'Loaded ' +\n              data.file +\n              ' ' +\n              '(' +\n              data.current +\n              '/' +\n              data.total +\n              ').'\n          )\n        }\n      }\n      worker.onerror = function (e) {\n        onMessage('Worker error: ' + e)\n        console.error('Worker error: ' + e)\n        reject(e.error)\n      }\n      worker.postMessage({ files })\n    })\n    song.bemusepack_url = null\n    return song\n  }\n}\n\nexport interface LoadSongOptions {\n  onMessage?: (message: string) => void\n}\n","import { INITIAL_OPERATION_STATE, Operation } from './operations'\nimport { Observable, distinct, map, scan } from 'rxjs'\n\nimport Immutable from 'immutable'\n\nexport type Action<T> =\n  | { type: 'PUT'; data: Record<string, Operation<T>> }\n  | { type: 'CLEAR' }\n\nexport function put<T>(id: string, transition: Operation<T>) {\n  return putMultiple({ [id]: transition })\n}\n\nexport function putMultiple<T>(transitions: Record<string, Operation<T>>) {\n  return { type: PUT, data: transitions } as const\n}\n\nexport function clear() {\n  return { type: CLEAR } as const\n}\n\nconst PUT = 'PUT'\nconst CLEAR = 'CLEAR'\n\nexport type DataStore<T> = Immutable.Map<string, Operation<T>>\n\nexport const initialState = <T>(): DataStore<T> =>\n  Immutable.Map<string, Operation<T>>()\n\nexport function store川<T>(\n  action川: Observable<Action<T>>\n): Observable<DataStore<T>> {\n  return action川.pipe(scan(reduce, initialState()))\n}\n\nexport function item川<T>(state川: Observable<DataStore<T>>, id: string) {\n  return state川.pipe(map((state) => get(state, id))).pipe(distinct())\n}\n\nexport function reduce<T>(\n  state: DataStore<T> = initialState(),\n  action: Action<T>\n): DataStore<T> {\n  switch (action.type) {\n    case PUT: {\n      const stateChanges = Immutable.Map(action.data)\n      return state.merge(stateChanges)\n    }\n    case CLEAR: {\n      return initialState<T>()\n    }\n    default: {\n      return state\n    }\n  }\n}\n\nexport function get<T>(state: DataStore<T>, id: string): Operation<T> {\n  return state.get(id, INITIAL_OPERATION_STATE)\n}\n\nexport function has<T>(state: DataStore<T>, id: string) {\n  return state.has(id)\n}\n","// Key mapping\n\nexport const MAPPING_MODES = ['KB', 'BM'] as const\nexport const isMappingMode = (str: string): str is MappingMode =>\n  (MAPPING_MODES as readonly string[]).includes(str)\nexport type MappingMode = typeof MAPPING_MODES[number]\n","import { MappingMode, isMappingMode } from 'bemuse/rules/mapping-mode'\n\nimport invariant from 'invariant'\n\nexport interface RecordLevel {\n  md5: string\n  playMode: MappingMode\n}\n\nexport function fromObject({\n  md5,\n  playMode,\n}: {\n  md5?: unknown\n  playMode?: unknown\n}): RecordLevel {\n  invariant(typeof md5 === 'string', 'md5 must be a string')\n  invariant(typeof playMode === 'string', 'playMode must be a string')\n  invariant(isMappingMode(playMode), 'playMode must be a MappingMode')\n  return { md5, playMode }\n}\n","export function id({ md5, playMode }) {\n  return `${md5}-${playMode}`\n}\n\nexport default id\n","export class BatchedFetcher<T> {\n  constructor(\n    private onFetch: (md5s: string[]) => Promise<T[]>,\n    private getMd5: (t: T) => string\n  ) {}\n\n  private pending: {\n    set: Set<string>\n    promise: Promise<Map<string, T[]>>\n  } | null = null\n\n  load(md5: string): Promise<T[]> {\n    if (!this.pending) {\n      const set = new Set<string>()\n      this.pending = {\n        set,\n        promise: new Promise((resolve) => {\n          setTimeout(() => {\n            this.pending = null\n            const md5s = Array.from(set)\n            resolve(\n              this.onFetch(md5s).then((result) => {\n                const map = new Map<string, T[]>()\n                for (const t of result) {\n                  const md5 = this.getMd5(t)\n                  const list = map.get(md5) || []\n                  list.push(t)\n                  map.set(md5, list)\n                }\n                return map\n              })\n            )\n          }, 138)\n        }),\n      }\n    }\n    this.pending.set.add(md5)\n    return this.pending.promise.then((map) => map.get(md5) || [])\n  }\n}\n","import {\n  Action,\n  DataStore,\n  initialState,\n  put,\n  putMultiple,\n  store川,\n} from './data-store'\nimport {\n  INITIAL_OPERATION_STATE,\n  Operation,\n  completed,\n  operation川FromPromise,\n} from './operations'\nimport {\n  Observable,\n  ObservableInput,\n  Subject,\n  asapScheduler,\n  bufferTime,\n  combineLatest,\n  concatMap,\n  distinctUntilChanged,\n  from,\n  map,\n  merge,\n  of,\n  scan,\n  scheduled,\n  shareReplay,\n  startWith,\n  switchMap,\n} from 'rxjs'\nimport { RecordLevel, fromObject } from './level'\n\nimport Immutable from 'immutable'\nimport { ScoreCount } from 'bemuse/rules/accuracy'\nimport _ from 'lodash'\nimport id from './id'\nimport { queryClient } from 'bemuse/react-query'\nimport { rootQueryKey } from './queryKeys'\nimport { BatchedFetcher } from './BatchedFetcher'\n\nexport interface SignUpInfo {\n  username: string\n  password: string\n  email: string\n}\n\nexport interface LogInInfo {\n  username: string\n  password: string\n}\n\nexport interface UserInfo {\n  username: string\n}\n\nexport interface ChangePasswordInfo {\n  email: string\n}\n\nexport interface ScoreBase {\n  score: number\n  combo: number\n  count: ScoreCount\n  total: number\n  log: string\n}\n\nexport type ScoreInfo = ScoreBase & RecordLevel\n\nexport type RankingInfo = Partial<ScoreBase> & RecordLevel\n\nconst scoreInfoGuard = (data: ScoreInfo | RankingInfo): data is ScoreInfo =>\n  !!data.score\n\nexport interface ScoreboardDataEntry {\n  rank?: number\n  score: number\n  combo?: number\n  count: ScoreCount\n  total: number\n  playerName: string\n  recordedAt?: Date\n  playCount?: number\n  playNumber?: number\n}\n\nexport type ScoreboardDataRecord = ScoreboardDataEntry & RecordLevel\n\nexport type SubmissionOperation =\n  | Operation<ScoreboardDataEntry | null>\n  | Readonly<{\n      status: 'unauthenticated'\n    }>\n\nexport interface RankingState {\n  data: ScoreboardDataEntry[] | null\n  meta: {\n    submission: SubmissionOperation\n    scoreboard: Operation<ScoreboardDataEntry | null>\n  }\n}\n\nexport interface InternetRankingService {\n  getCurrentUser(): UserInfo | null\n  signUp(signUpInfo: SignUpInfo): Promise<UserInfo | null>\n  logIn(logInInfo: LogInInfo): Promise<UserInfo | null>\n  changePassword(changePasswordInfo: ChangePasswordInfo): Promise<object>\n  logOut(): Promise<void>\n  submitScore(scoreInfo: ScoreInfo): Promise<ScoreboardDataRecord>\n  retrieveRecord(level: RecordLevel): Promise<ScoreboardDataRecord | null>\n  retrieveScoreboard(\n    level: RecordLevel\n  ): Promise<{ data: ScoreboardDataEntry[] }>\n  retrieveMultipleRecords(\n    levels: readonly { md5: string }[]\n  ): Promise<ScoreboardDataRecord[]>\n}\n\n/** @deprecated */\nexport interface RankingStream {\n  /** @deprecated */\n  state川: Observable<RankingState>\n\n  /** @deprecated */\n  resubmit: () => void\n\n  /** @deprecated */\n  reloadScoreboard: () => void\n}\n\nexport class Online {\n  constructor(private readonly service: InternetRankingService) {}\n\n  /** @deprecated */\n  private user口 = new Subject<UserInfo | null>()\n\n  /** @deprecated */\n  private seen口 = new Subject<RecordLevel>()\n\n  /** @deprecated */\n  private submitted口 = new Subject<ScoreboardDataRecord>()\n\n  /** @deprecated - Use getCurrentUser() instead */\n  user川 = this.user口\n    .pipe(startWith(null))\n    .pipe(shareReplay(1))\n    .pipe(map((user) => user || this.service.getCurrentUser()))\n\n  getCurrentUser() {\n    return this.service.getCurrentUser()\n  }\n\n  async signUp(options: SignUpInfo) {\n    const user = await this.service.signUp(options)\n    this.user口.next(user)\n    queryClient.invalidateQueries({ queryKey: rootQueryKey })\n    return user\n  }\n\n  async logIn(options: LogInInfo) {\n    const user = await this.service.logIn(options)\n    this.user口.next(user)\n    queryClient.invalidateQueries({ queryKey: rootQueryKey })\n    return user\n  }\n\n  batchedRecordFetcher = new BatchedFetcher<ScoreboardDataRecord>(\n    (md5s) =>\n      this.service.retrieveMultipleRecords(md5s.map((md5) => ({ md5 }))),\n    (record) => record.md5\n  )\n\n  getPersonalRecordsByMd5(md5: string) {\n    if (!this.service.getCurrentUser()) return []\n    return this.batchedRecordFetcher.load(md5)\n  }\n\n  changePassword(options: ChangePasswordInfo) {\n    return Promise.resolve(this.service.changePassword(options))\n  }\n\n  async logOut(): Promise<void> {\n    await this.service.logOut()\n    this.user口.next(null)\n    queryClient.invalidateQueries({ queryKey: rootQueryKey })\n  }\n\n  async submitScore(info: ScoreInfo) {\n    if (!this.service.getCurrentUser()) {\n      throw new Error('Unauthenticated.')\n    }\n    const record = await this.service.submitScore(info)\n    this.submitted口.next(record)\n    return record\n  }\n\n  scoreboard(level: RecordLevel) {\n    return this.service.retrieveScoreboard(level)\n  }\n\n  retrievePersonalRankingEntry(level: RecordLevel) {\n    if (!this.service.getCurrentUser()) return null\n    return this.service.retrieveRecord(level)\n  }\n\n  private allSeen川 = this.allSeen川ForJustSeen川(this.seen口)\n\n  private allSeen川ForJustSeen川(\n    justSeen川: Observable<RecordLevel>\n  ): Observable<RecordLevel[]> {\n    return justSeen川\n      .pipe(bufferTime(138))\n      .pipe(\n        scan(\n          (map, seen) =>\n            map.merge(Immutable.Map(_.zipObject(seen.map(id), seen))),\n          Immutable.Map<string, RecordLevel>()\n        )\n      )\n      .pipe(map((map) => map.valueSeq()))\n      .pipe(distinctUntilChanged(Immutable.is))\n      .pipe(map((seq) => seq.toArray()))\n  }\n\n  private fetchRecords = async (\n    levels: readonly RecordLevel[],\n    user: UserInfo | null,\n    seen: Set<string>\n  ): Promise<Action<ScoreboardDataRecord | null>> => {\n    const levelsToFetch = levels.filter((level) => !seen.has(id(level)))\n    for (const level of levelsToFetch) {\n      seen.add(id(level))\n    }\n    const results =\n      user && levelsToFetch.length > 0\n        ? await this.service.retrieveMultipleRecords(levelsToFetch)\n        : []\n    try {\n      const loadedRecords = _.zipObject(results.map(id), results.map(completed))\n      const nullResults = _.zipObject(\n        levelsToFetch.map(id),\n        levelsToFetch.map(() => completed(null))\n      )\n      const transitions = _.defaults(loadedRecords, nullResults)\n      return putMultiple<ScoreboardDataRecord | null>(transitions)\n    } catch (e: unknown) {\n      console.error('Cannot fetch levels:', e)\n      return putMultiple({})\n    }\n  }\n\n  private records川ForUser = (\n    user: UserInfo | null\n  ): Observable<DataStore<ScoreboardDataRecord | null>> => {\n    const seen = new Set<string>()\n\n    const action川 = merge(\n      this.allSeen川.pipe(\n        concatMap((x) => from(this.fetchRecords(x, user, seen)))\n      ),\n      this.submitted口.pipe(map((record) => put(id(record), completed(record))))\n    )\n    return store川(action川)\n  }\n\n  /** @deprecated */\n  records川 = this.user川\n    .pipe(switchMap(this.records川ForUser))\n    .pipe(startWith(initialState<ScoreboardDataRecord | null>()))\n    .pipe(shareReplay(1))\n\n  dispose() {}\n\n  /** @deprecated */\n  Ranking(data: RankingInfo): RankingStream {\n    const level: RecordLevel = fromObject(data)\n    const retrySelf口 = new Subject<void>()\n    const retryScoreboard口 = new Subject<void>()\n\n    const self川 = this.self川ForUser(retrySelf口, data)\n    const scoreboard川 = self川\n      .pipe(\n        switchMap(() => this.getScoreboardState川(retryScoreboard口, level))\n      )\n      .pipe(shareReplay(1))\n    const state川 = combineLatest({\n      self: self川,\n      scoreboard: scoreboard川,\n    }).pipe(map(this.conformState))\n    return {\n      state川,\n      resubmit: () => retrySelf口.next(),\n      reloadScoreboard: () => retryScoreboard口.next(),\n    }\n  }\n\n  // Make the state conform the old API. We should remove this in the future.\n  private conformState = ({\n    self,\n    scoreboard,\n  }: {\n    self: SubmissionOperation\n    scoreboard: Operation<{ data: ScoreboardDataEntry[] }>\n  }): RankingState => ({\n    data:\n      scoreboard.status === 'completed' ? scoreboard.value?.data ?? null : null,\n    meta: {\n      scoreboard: _.omit(scoreboard, 'value') as Operation<ScoreboardDataEntry>,\n      submission: { ...self } as Operation<ScoreboardDataEntry>,\n    },\n  })\n\n  private self川ForUser = (\n    retrySelfBus: Observable<void>,\n    data: ScoreInfo | RankingInfo\n  ): Observable<SubmissionOperation> =>\n    this.user川\n      .pipe(\n        switchMap((user) => {\n          if (!user) {\n            return this.unauthenticatedRankingModel()\n          }\n          if (scoreInfoGuard(data)) {\n            return this.submissionModel(retrySelfBus, data)\n          }\n          return this.viewRecordModel(retrySelfBus, data)\n        })\n      )\n      .pipe(startWith(INITIAL_OPERATION_STATE))\n      .pipe(shareReplay(1))\n\n  private unauthenticatedRankingModel = (): Observable<SubmissionOperation> =>\n    of({\n      status: 'unauthenticated',\n      error: null,\n      record: null,\n    })\n\n  private submissionModel = (\n    retrySelfBus: Observable<void>,\n    data: ScoreInfo\n  ): Observable<SubmissionOperation> =>\n    merge(this.asap川([[]]), retrySelfBus).pipe(\n      switchMap(() => operation川FromPromise(this.submitScore(data)))\n    )\n\n  private viewRecordModel = (\n    retrySelfBus: Observable<void>,\n    data: RankingInfo\n  ): Observable<SubmissionOperation> =>\n    merge(this.asap川([[]]), retrySelfBus).pipe(\n      switchMap(() => operation川FromPromise(this.service.retrieveRecord(data)))\n    )\n\n  private getScoreboardState川 = (\n    retryScoreboardBus: Observable<void>,\n    level: RecordLevel\n  ): Observable<Operation<{ data: ScoreboardDataEntry[] }>> =>\n    merge(this.asap川([[]]), retryScoreboardBus).pipe(\n      switchMap(() => operation川FromPromise(this.scoreboard(level)))\n    )\n\n  private asap川 = <T>(input: ObservableInput<T>) =>\n    scheduled(input, asapScheduler)\n\n  seen(level: RecordLevel) {\n    return this.seen口.next(level)\n  }\n}\n\nexport default Online\n","import { Observable, from, startWith } from 'rxjs'\n\nexport type Pending = {\n  status: 'pending'\n}\n\nexport type Loading = {\n  status: 'loading'\n}\n\nexport type Waiting = Pending | Loading\n\nexport type Completed<T> = {\n  status: 'completed'\n  value: T\n}\n\nexport type Errored = {\n  status: 'error'\n  error: Error\n}\n\n// An asynchronous operation may be in four states:\n//\n// 0. Pending\n// 1. Loading\n// 2. Completed\n// 3. Error\n//\nexport type Operation<T> = Readonly<Waiting | Completed<T> | Errored>\n\n// A constant representing the initial state of an asynchronous operation\n// that may be repeated:\nexport const INITIAL_OPERATION_STATE = {\n  status: 'pending',\n} as const\n\nexport function loading() {\n  return { status: 'loading' } as const\n}\n\nexport function completed<T>(value: T): Operation<T> {\n  return { status: 'completed', value }\n}\n\nexport function error(error: Error) {\n  return { status: 'error', error } as const\n}\n\nexport function transition<T>(\n  previousState: Operation<T> = INITIAL_OPERATION_STATE,\n  transition: Operation<T>\n): Operation<T> {\n  return Object.assign({}, previousState, transition)\n}\n\nexport function isWaiting<T>(state: Operation<T>): state is Waiting {\n  return state.status === 'loading' || state.status === 'pending'\n}\n\n// Returns a Promise representing the outcome of a given promise.\n// This promise will never be rejected, but will always resolve with a state transition object.\nexport function outcomeOfPromise<T>(\n  promise: PromiseLike<T>\n): Promise<Operation<T>> {\n  return Promise.resolve(promise).then(completed, error)\n}\n\nexport function operation川FromPromise<T>(\n  promise: PromiseLike<T>\n): Observable<Operation<T>> {\n  return from(outcomeOfPromise(promise)).pipe(startWith(loading()))\n}\n","import { MappingMode } from 'bemuse/rules/mapping-mode'\nimport { QueryKey } from 'react-query'\n\nexport const rootQueryKey: QueryKey = ['online']\n\nexport const currentUserQueryKey: QueryKey = ['online', 'currentUser']\n\nexport const getPersonalRecordQueryKey: (md5: string) => QueryKey = (md5) => [\n  'online',\n  'personalRecord',\n  md5,\n]\n\nexport const getLeaderboardQueryKey: (\n  md5: string,\n  playMode: MappingMode\n) => QueryKey = (md5, playMode) => ['online', 'leaderboard', md5, playMode]\n\nexport const getPersonalRankingEntryQueryKey: (\n  md5: string,\n  playMode: MappingMode\n) => QueryKey = (md5, playMode) => [\n  'online',\n  'personalRankingEntry',\n  md5,\n  playMode,\n]\n","import {\n  ScoreboardClient,\n  ScoreboardEntry,\n  ScoreboardRow,\n} from './ScoreboardClient'\n\nimport { MappingMode } from 'bemuse/rules/mapping-mode'\nimport ObjectID from 'bson-objectid'\nimport type { ScoreCount } from 'bemuse/rules/accuracy'\nimport delay from 'delay'\n\ninterface Submission {\n  md5: string\n  playMode: MappingMode\n  entry: ScoreboardEntry\n}\n\nexport function createFakeScoreboardClient(): ScoreboardClient {\n  let submissions: Submission[] = []\n  const signedUpUsernames = new Set<string>()\n\n  const client: ScoreboardClient = {\n    signUp: async (options) => {\n      await delay(100)\n      if (signedUpUsernames.has(options.username)) {\n        throw new Error('Username already taken')\n      }\n      signedUpUsernames.add(options.username)\n      return { playerToken: 'FAKE!' + options.username }\n    },\n    loginByUsernamePassword: async (options) => {\n      await delay(100)\n      return { playerToken: 'FAKE!' + options.username }\n    },\n    changePassword: async (options) => {\n      return {}\n    },\n    renewPlayerToken: async (options) => {\n      return options.playerToken\n    },\n    submitScore: async (options) => {\n      await delay(100)\n      const { username } = decodeFakePlayerToken(options.playerToken)\n      const matching = (s: Submission): boolean =>\n        s.md5 === options.md5 &&\n        s.playMode === options.playMode &&\n        s.entry.player.name === username\n      const existingSubmission = submissions.find(matching)\n      const newScoreboardEntry = updateScoreboardEntry(\n        existingSubmission?.entry,\n        options.input,\n        { name: username }\n      )\n      submissions = submissions.filter((s) => !matching(s))\n      submissions.push({\n        md5: options.md5,\n        playMode: options.playMode,\n        entry: newScoreboardEntry,\n      })\n      return {\n        data: {\n          registerScore: {\n            resultingRow: getRow(options.md5, options.playMode, username)!,\n          },\n        },\n      }\n    },\n    retrieveRankingEntries: async (options) => {\n      if (!options.md5s.every((x) => typeof x === 'string')) {\n        console.error('Invalid md5s...', options.md5s)\n        throw new Error('Invalid md5s (this is a programmer error)')\n      }\n      await delay(100)\n      const { username } = decodeFakePlayerToken(options.playerToken)\n      const set = new Set<string>(options.md5s)\n      return {\n        data: {\n          me: {\n            records: submissions.filter(\n              (s) => set.has(s.md5) && s.entry.player.name === username\n            ),\n          },\n        },\n      }\n    },\n    retrieveRecord: async (options) => {\n      await delay(100)\n      const { username } = decodeFakePlayerToken(options.playerToken)\n      return {\n        data: {\n          chart: {\n            level: {\n              myRecord: getRow(options.md5, options.playMode, username),\n            },\n          },\n        },\n      }\n    },\n    retrieveScoreboard: async (options) => {\n      await delay(100)\n      return {\n        data: {\n          chart: {\n            level: {\n              leaderboard: getChartSubmissions(\n                options.md5,\n                options.playMode\n              ).map((s, i) => ({ rank: i + 1, entry: s.entry })),\n            },\n          },\n        },\n      }\n    },\n  }\n\n  function getRow(\n    md5: string,\n    playMode: string,\n    username: string\n  ): ScoreboardRow | null {\n    const chartSubmissions = getChartSubmissions(md5, playMode)\n    const mySubmission = chartSubmissions.find(\n      (s) => s.entry.player.name === username\n    )\n    if (!mySubmission) {\n      return null\n    }\n    const myRank =\n      chartSubmissions.filter((s) => s.entry.score > mySubmission.entry.score)\n        .length + 1\n    return {\n      rank: myRank,\n      entry: mySubmission.entry,\n    }\n  }\n\n  function getChartSubmissions(md5: string, playMode: string) {\n    return submissions\n      .filter((s) => s.md5 === md5 && s.playMode === playMode)\n      .sort((a, b) => b.entry.score - a.entry.score)\n  }\n\n  return client\n}\n\nfunction decodeFakePlayerToken(token: string) {\n  if (!token.startsWith('FAKE!')) {\n    throw new Error('Invalid player token: ' + token)\n  }\n  return { username: token.replace(/^FAKE!/, '') }\n}\n\nexport interface ScoreData {\n  score: number\n  combo: number\n  count: ScoreCount\n  total: number\n  log: string\n}\n\nexport function updateScoreboardEntry(\n  original: ScoreboardEntry | null | undefined,\n  data: ScoreData,\n  player: { name: string }\n): ScoreboardEntry {\n  const nextPlayCount = (original?.playCount || 0) + 1\n  const score = +data.score\n  if (!original || score > original.score) {\n    return Object.assign({}, original || {}, {\n      id: original?.id || ObjectID.generate(),\n      score: score,\n      playCount: nextPlayCount,\n      playNumber: nextPlayCount,\n      combo: +data.combo || 0,\n      count: [\n        +data.count[0] || 0,\n        +data.count[1] || 0,\n        +data.count[2] || 0,\n        +data.count[3] || 0,\n        +data.count[4] || 0,\n      ] as [number, number, number, number, number],\n      total: +data.total || 0,\n      recordedAt: new Date().toJSON(),\n      player: player,\n    })\n  } else {\n    return Object.assign({}, original, {\n      playCount: nextPlayCount,\n    })\n  }\n}\n","import axios from 'axios'\nimport invariant from 'invariant'\n\nimport { ScoreboardClient, ScoreboardRow } from './ScoreboardClient'\n\nexport interface CreateScoreboardClientOptions {\n  /**\n   * The URL of the scoreboard server.\n   */\n  server: string\n\n  log: unknown\n}\n\nexport function createNextScoreboardClient({\n  server,\n}: CreateScoreboardClientOptions): ScoreboardClient {\n  const client = axios.create({\n    baseURL: server,\n  })\n\n  async function getMyRecord(\n    playerToken: string,\n    md5: string,\n    playMode: string\n  ) {\n    const response = await client\n      .get(`/api/scoreboard/${md5}/${playMode}/mine`, {\n        headers: { Authorization: `Bearer ${playerToken}` },\n      })\n      .catch(handleAxiosError('Unable to retrieve personal records'))\n    return response.data.data as ScoreboardRow\n  }\n\n  const scoreboardClient: ScoreboardClient = {\n    async signUp({ username, password, email }) {\n      invariant(typeof username === 'string', 'username must be a string')\n      invariant(typeof password === 'string', 'password must be a string')\n      invariant(typeof email === 'string', 'email must be a string')\n      const response = await client\n        .post('/api/auth/signup', {\n          username,\n          password,\n          email,\n        })\n        .catch(handleAxiosError('Unable to sign up'))\n      return { playerToken: response.data.playerToken }\n    },\n    async loginByUsernamePassword({ username, password }) {\n      invariant(typeof username === 'string', 'username must be a string')\n      invariant(typeof password === 'string', 'password must be a string')\n      const response = await client\n        .post('/api/auth/login', {\n          username,\n          password,\n        })\n        .catch(handleAxiosError('Unable to log in'))\n      return { playerToken: response.data.playerToken }\n    },\n    async changePassword({ email }) {\n      await client\n        .post('/api/auth/reset', { email })\n        .catch(handleAxiosError('Unable to request password reset'))\n      return {}\n    },\n    async submitScore({ playerToken, md5, playMode, input }) {\n      await client\n        .post(\n          `/api/scoreboard/${md5}/${playMode}/submit`,\n          { scoreData: input },\n          { headers: { Authorization: `Bearer ${playerToken}` } }\n        )\n        .catch(handleAxiosError('Unable to submit score'))\n      return {\n        data: {\n          registerScore: {\n            resultingRow: await getMyRecord(playerToken, md5, playMode),\n          },\n        },\n      }\n    },\n    async retrieveScoreboard({ md5, playMode }) {\n      const response = await client\n        .get(`/api/scoreboard/${md5}/${playMode}/leaderboard`)\n        .catch(handleAxiosError('Unable to retrieve leaderboard'))\n      return {\n        data: {\n          chart: {\n            level: {\n              leaderboard: response.data.data,\n            },\n          },\n        },\n      }\n    },\n    async retrieveRecord({ playerToken, md5, playMode }) {\n      return {\n        data: {\n          chart: {\n            level: {\n              myRecord: await getMyRecord(playerToken, md5, playMode),\n            },\n          },\n        },\n      }\n    },\n    async retrieveRankingEntries({ playerToken, md5s }) {\n      const response = await client\n        .post(\n          `/api/scoreboard/records`,\n          { md5s },\n          { headers: { Authorization: `Bearer ${playerToken}` } }\n        )\n        .catch(handleAxiosError('Unable to retrieve ranking entries'))\n      return {\n        data: {\n          me: {\n            records: response.data.data,\n          },\n        },\n      }\n    },\n    async renewPlayerToken({ playerToken }) {\n      const response = await client\n        .post(\n          '/api/auth/renew',\n          {},\n          {\n            headers: { Authorization: `Bearer ${playerToken}` },\n          }\n        )\n        .catch(handleAxiosError('Unable to renew token'))\n      return response.data.playerToken\n    },\n  }\n\n  return scoreboardClient\n}\nfunction handleAxiosError(prefix: string) {\n  return (error: any): never => {\n    if (axios.isAxiosError(error)) {\n      const data = error.response?.data\n      const message = data?.message\n      const suffix = message ? `: ${message}` : ''\n      if (data) {\n        throw new Error(`${prefix}: ${error}${suffix}`)\n      }\n    }\n    throw error\n  }\n}\n","import type {\n  InternetRankingService,\n  ChangePasswordInfo,\n  LogInInfo,\n  ScoreInfo,\n  ScoreboardDataEntry,\n  SignUpInfo,\n} from '..'\nimport { ScoreboardClient, ScoreboardRow } from './ScoreboardClient'\n\nimport { RecordLevel } from '../level'\nimport { createFakeScoreboardClient } from './createFakeScoreboardClient'\nimport { createNextScoreboardClient } from './createNextScoreboardClient'\nimport { isTestModeEnabled } from 'bemuse/devtools/BemuseTestMode'\n\nexport interface OnlineServiceOptions {\n  fake?: boolean\n  server?: string\n  storagePrefix?: string\n  storage?: Storage\n}\n\ninterface User {\n  username: string\n  playerToken: string\n}\n\nexport class OnlineService implements InternetRankingService {\n  private _isFake: boolean\n  private _scoreboardClient: ScoreboardClient\n  private _storage: Storage\n  private _storagePrefix: string\n  private _currentUser: User | undefined\n\n  constructor({\n    fake = false,\n    server,\n    storagePrefix = fake ? 'fake-scoreboard.auth' : 'scoreboard.auth',\n    storage = localStorage,\n  }: OnlineServiceOptions) {\n    this._isFake = fake\n    this._scoreboardClient =\n      fake || !server\n        ? createFakeScoreboardClient()\n        : createNextScoreboardClient({ server, log: () => {} })\n    this._storage = storage\n    this._storagePrefix = storagePrefix\n    this._updateUserFromStorage()\n    this._renewPlayerToken()\n  }\n\n  _updateUserFromStorage() {\n    const loadUser = (text: string | null) => {\n      if (!text) return null\n      try {\n        const data = JSON.parse(text)\n        const playerToken = data.playerToken\n        const playerTokenExpires = playerToken.startsWith('FAKE!')\n          ? Date.now() + 86400e3 * 7\n          : JSON.parse(atob(playerToken.split('.')[1])).exp * 1000\n        if (Date.now() > playerTokenExpires - 86400e3) {\n          console.warn('Authentication token is about to expire, skipping!')\n          return null\n        }\n        return data\n      } catch (e) {\n        return null\n      }\n    }\n    this._currentUser = loadUser(\n      this._storage.getItem(`${this._storagePrefix}.id`)\n    )\n  }\n\n  _renewPlayerToken() {\n    if (!this._currentUser) {\n      return\n    }\n    const { playerToken, username } = this._currentUser\n    return this._scoreboardClient\n      .renewPlayerToken({ playerToken })\n      .then((newToken) => {\n        if (this._storage.getItem(`${this._storagePrefix}.id`)) {\n          this._storage.setItem(\n            `${this._storagePrefix}.id`,\n            JSON.stringify({\n              username: username,\n              playerToken: newToken,\n            })\n          )\n        }\n      })\n  }\n\n  getCurrentUser() {\n    if (this._currentUser && this._currentUser.playerToken) {\n      return { username: this._currentUser.username }\n    } else {\n      return null\n    }\n  }\n\n  isLoggedIn() {\n    return !!this._currentUser\n  }\n\n  signUp({ username, password, email }: SignUpInfo) {\n    return this._scoreboardClient\n      .signUp({ username, password, email })\n      .then((signUpResult) => {\n        this._storage.setItem(\n          `${this._storagePrefix}.id`,\n          JSON.stringify({\n            username: username,\n            playerToken: signUpResult.playerToken,\n          })\n        )\n        this._updateUserFromStorage()\n        return this.getCurrentUser()\n      })\n  }\n\n  logIn({ username, password }: LogInInfo) {\n    return this._scoreboardClient\n      .loginByUsernamePassword({ username, password })\n      .then((loginResult) => {\n        this._storage.setItem(\n          `${this._storagePrefix}.id`,\n          JSON.stringify({\n            username: username,\n            playerToken: loginResult.playerToken,\n          })\n        )\n        this._updateUserFromStorage()\n        return this.getCurrentUser()\n      })\n  }\n\n  changePassword({ email }: ChangePasswordInfo) {\n    return this._scoreboardClient.changePassword({ email })\n  }\n\n  async logOut() {\n    this._storage.removeItem(`${this._storagePrefix}.id`)\n    this._updateUserFromStorage()\n  }\n\n  async submitScore(info: ScoreInfo) {\n    if (isTestModeEnabled() && !this._isFake) {\n      throw new Error('Cannot submit score in test mode')\n    }\n    if (!this._currentUser) {\n      throw new Error('Not logged in')\n    }\n    const result = await this._scoreboardClient.submitScore({\n      playerToken: this._currentUser.playerToken,\n      md5: info.md5,\n      playMode: info.playMode,\n      input: {\n        score: info.score,\n        combo: info.combo,\n        count: info.count,\n        total: info.total,\n        log: info.log,\n      },\n    })\n    const data = {\n      md5: info.md5,\n      playMode: info.playMode,\n      ...toEntry(result.data.registerScore.resultingRow),\n    }\n    return data\n  }\n\n  // Retrieves a record.\n  //\n  // Returns a record object.\n  async retrieveRecord(level: RecordLevel) {\n    if (!this._currentUser) {\n      throw new Error('Not logged in')\n    }\n    const result = await this._scoreboardClient.retrieveRecord({\n      playerToken: this._currentUser.playerToken,\n      md5: level.md5,\n      playMode: level.playMode,\n    })\n    const myRecord = result.data.chart.level.myRecord\n    return (\n      myRecord && {\n        md5: level.md5,\n        playMode: level.playMode,\n        ...toEntry(myRecord),\n      }\n    )\n  }\n\n  // Retrieves the scoreboard\n  async retrieveScoreboard({ md5, playMode }: RecordLevel) {\n    const result = await this._scoreboardClient.retrieveScoreboard({\n      md5,\n      playMode,\n    })\n    return { data: result.data.chart.level.leaderboard.map(toEntry) }\n  }\n\n  // Retrieve multiple records!\n  //\n  // Items is an array of song items. They have a md5 property.\n  async retrieveMultipleRecords(items: readonly { md5: string }[]) {\n    if (!this._currentUser) {\n      throw new Error('Not logged in')\n    }\n    const result = await this._scoreboardClient.retrieveRankingEntries({\n      playerToken: this._currentUser.playerToken,\n      md5s: items.map((item) => item.md5),\n    })\n    const entries = result.data.me.records.map((item) => ({\n      ...toEntry(item),\n      md5: item.md5,\n      playMode: item.playMode,\n    }))\n    return entries\n  }\n}\n\nexport default OnlineService\n\nfunction toEntry(row: ScoreboardRow): ScoreboardDataEntry {\n  return {\n    rank: row.rank,\n    score: row.entry.score,\n    combo: row.entry.combo,\n    count: row.entry.count,\n    total: row.entry.total,\n    playerName: row.entry.player.name,\n    recordedAt: new Date(row.entry.recordedAt),\n    playCount: row.entry.playCount,\n    playNumber: row.entry.playNumber,\n  }\n}\n","import { QueryClient } from 'react-query'\n\nexport const queryClient = new QueryClient()\n"],"names":["deltas","meticulousWindow","preciseWindow","sum","delta","difference","Math","abs","CustomFolderContextImpl","get","set","del","CUSTOM_FOLDER_KEYVAL_KEY","async","setCustomFolder","context","folder","handle","clearCustomFolder","getCustomFolderState","getDefaultCustomFolderContext","scanFolder","io","state","log","setStatus","updateState","i","result","scanIteration","nextState","moreIterationsNeeded","chartFilesScanned","inputState","message","permission","queryPermission","mode","requestPermission","checkFolderStateAndPermissions","foldersToUpdate","length","n","songsToSave","updatedPathSet","Set","deadline","Date","now","entries","add","JSON","stringify","path","pathStr","formatPath","remaining","statusPrefix","resources","getResourcesForFolder","chartFiles","_unused","song","onMessage","text","charts","push","songsToSavePathSet","map","newSongs","songs","filter","has","newFoldersToUpdate","updateFolders","foldersToRemove","remainingSongs","removedPathSet","includes","newFoldersToRemove","removeFolders","chartFileScanner","ChartFileScanner","searchForChartFiles","newChartFiles","getNewChartFiles","getFoldersToUpdate","getFoldersToRemove","getFolderCount","join","scanAllChartFiles","directoryHandle","parentPath","entriesRead","name","childPath","kind","test","fileHandle","addPath","getModifiedDate","getFile","lastModified","error","console","rootFolderHandle","folderHandle","getFolderHandleByPath","files","file","every","p","fileList","Promise","resolve","getFileHandle","getDirectoryHandle","constructor","previous","fast","foundFolderSet","updatedFolderSet","changedPaths","this","existingMap","Map","existingFolderSet","slice","key","folderKey","existing","parse","size","getSongsFromCustomFolders","customFolderSongs","resourceFactory","CustomFolderResourceFactory","out","customFolderSong","getResources","custom","id","e","getGrant","Error","getFolderHandle","loadSongFromResources","options","setLoggingFunction","then","data","read","Blob","loadFromBemuseSongJson","bmsFileList","all","filename","start","reject","worker","Worker","URL","onmessage","type","terminate","current","total","onerror","postMessage","bemusepack_url","loadFromBmsFileList","loadFromFileList","put","transition","putMultiple","transitions","PUT","clear","CLEAR","initialState","pipe","reduce","action","stateChanges","merge","MAPPING_MODES","fromObject","md5","playMode","str","BatchedFetcher","onFetch","getMd5","pending","load","promise","setTimeout","md5s","Array","from","t","list","service","Subject","startWith","shareReplay","user","getCurrentUser","batchedRecordFetcher","retrieveMultipleRecords","record","fetchRecords","levels","seen","levelsToFetch","level","results","loadedRecords","nullResults","concatMap","x","switchMap","conformState","self","scoreboard","status","value","meta","submission","retrySelfBus","score","scoreInfoGuard","submissionModel","viewRecordModel","unauthenticatedRankingModel","of","submitScore","retrieveRecord","retryScoreboardBus","input","scheduled","asap","signUp","next","queryKey","logIn","getPersonalRecordsByMd5","changePassword","logOut","info","retrieveScoreboard","retrievePersonalRankingEntry","bufferTime","scan","valueSeq","distinctUntilChanged","seq","toArray","dispose","Ranking","combineLatest","resubmit","reloadScoreboard","INITIAL_OPERATION_STATE","loading","completed","isWaiting","outcomeOfPromise","rootQueryKey","currentUserQueryKey","getPersonalRecordQueryKey","getLeaderboardQueryKey","getPersonalRankingEntryQueryKey","createFakeScoreboardClient","submissions","signedUpUsernames","getRow","username","chartSubmissions","getChartSubmissions","mySubmission","find","s","entry","player","rank","sort","a","b","playerToken","loginByUsernamePassword","renewPlayerToken","decodeFakePlayerToken","matching","existingSubmission","newScoreboardEntry","original","nextPlayCount","playCount","Object","assign","playNumber","combo","count","recordedAt","toJSON","updateScoreboardEntry","registerScore","resultingRow","retrieveRankingEntries","me","records","chart","myRecord","leaderboard","token","startsWith","replace","handleAxiosError","prefix","axios","response","fake","server","storagePrefix","storage","localStorage","_isFake","_scoreboardClient","client","baseURL","getMyRecord","headers","Authorization","catch","password","email","post","scoreData","createNextScoreboardClient","_storage","_storagePrefix","_updateUserFromStorage","_renewPlayerToken","_currentUser","playerTokenExpires","atob","split","exp","warn","loadUser","getItem","newToken","setItem","isLoggedIn","signUpResult","loginResult","removeItem","isTestModeEnabled","toEntry","items","item","row","playerName","queryClient","QueryClient"],"sourceRoot":""}