{"version":3,"file":"build/949-bdee35b7af71dc16977c.js","mappings":"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","sources":["file:///home/runner/work/bemuse/bemuse/bemuse/src/audio-context/index.js","file:///home/runner/work/bemuse/bemuse/bemuse/src/game/audio/player-audio.js","file:///home/runner/work/bemuse/bemuse/bemuse/src/game/audio/wave-factory.js","file:///home/runner/work/bemuse/bemuse/bemuse/src/game/input/touch-plugin.js","file:///home/runner/work/bemuse/bemuse/bemuse/src/game/loaders/samples-loader.js","file:///home/runner/work/bemuse/bemuse/bemuse/src/keysound-cache/createKeysoundCache.js","file:///home/runner/work/bemuse/bemuse/bemuse/src/keysound-cache/index.js","file:///home/runner/work/bemuse/bemuse/bemuse/src/resources/bemuse-package.ts","file:///home/runner/work/bemuse/bemuse/bemuse/src/sampling-master/index.js","file:///home/runner/work/bemuse/bemuse/bemuse/src/sampling-master/ogg.ts"],"sourcesContent":["export default new AudioContext({\n  latencyHint: 'interactive',\n})\n","import _ from 'lodash'\n\nimport WaveFactory from './wave-factory'\nimport { isBad } from '../judgments'\n\nfunction autoplayer(array) {\n  array = _.sortBy(array, 'time')\n  let i = 0\n  return {\n    next(time) {\n      const out = []\n      for (; i < array.length && time >= array[i].time; i++) {\n        out.push(array[i])\n      }\n      return out\n    },\n  }\n}\n\nexport class PlayerAudio {\n  constructor({ player, samples, master, waveFactory, volume }) {\n    const notechart = player.notechart\n    this._waveFactory =\n      waveFactory ||\n      new WaveFactory(master, samples, notechart.keysounds, { volume })\n    this._autos = autoplayer(notechart.autos)\n    this._notes = autoplayer(notechart.notes)\n    this._played = new Map()\n    this._autosound = !!player.options.autosound\n  }\n\n  update(time, state) {\n    this._playAutokeysounds(time)\n    this._playAutosounds(time, state)\n    this._handleSoundNotifications((state && state.notifications.sounds) || [])\n  }\n\n  _playAutokeysounds(time) {\n    for (const auto of this._autos.next(time + 1 / 30)) {\n      this._waveFactory.playAuto(auto, auto.time - time)\n    }\n  }\n\n  _playAutosounds(time, state) {\n    const autosounds = this._notes.next(time + 1 / 30)\n    const poor = state && state.stats.poor\n    const shouldPlay = this._autosound && !poor\n    if (!shouldPlay) return\n    for (const note of autosounds) {\n      this._hitNote(note, note.time - time)\n    }\n  }\n\n  _handleSoundNotifications(soundNotifications) {\n    for (const notification of soundNotifications) {\n      const { type, note } = notification\n      if (type === 'hit') {\n        this._hitNote(note, 0, notification.judgment)\n      } else if (type === 'break') {\n        this._breakNote(note)\n      } else if (type === 'free') {\n        this._waveFactory.playFree(note, 0)\n      }\n    }\n  }\n\n  _hitNote(note, delay, judgment) {\n    let instance = this._played.get(note)\n    if (!instance) {\n      instance = this._waveFactory.playNote(note, delay)\n      this._played.set(note, instance)\n    }\n    if (instance) {\n      if (isBad(judgment)) {\n        instance.bad()\n      }\n    }\n  }\n\n  _breakNote(note) {\n    const instance = this._played.get(note)\n    if (instance) {\n      instance.stop()\n    }\n  }\n}\n\nexport default PlayerAudio\n","export class WaveFactory {\n  constructor(master, samples, map, { volume } = {}) {\n    this._master = master\n    this._samples = samples\n    this._map = map\n    this._exclusiveInstances = new Map()\n    this._group = this._master.group({ volume })\n  }\n\n  // Plays an autokeysound note (using limited polyphony)\n  playAuto(note, delay, slice) {\n    return this._play({ note, delay, exclusive: true, slice })\n  }\n\n  // Plays a hit note (using limited polyphony)\n  // Returns the SoundInstance which may be stopped when hold note is missed\n  playNote(note, delay, slice) {\n    return this._play({ note, delay, exclusive: true, slice })\n  }\n\n  // Plays a note when hitting in the blank area (unlimited polyphony)\n  playFree(note, delay, slice) {\n    return this._play({ note, delay: 0, exclusive: false, slice })\n  }\n\n  // Plays a note\n  _play({ note, delay, exclusive }) {\n    const keysound = note.keysound\n    if (exclusive) this._stopOldExclusiveSound(keysound, delay)\n    const filename = this._map[keysound.toLowerCase()]\n    if (!filename) return null\n    const sample = this._samples[filename]\n    if (!sample) return null\n    const instance = sample.play(delay, {\n      start: note.keysoundStart,\n      end: note.keysoundEnd,\n      group: this._group,\n    })\n    if (exclusive) this._exclusiveInstances.set(keysound, instance)\n    return instance\n  }\n\n  _stopOldExclusiveSound(keysound, delay) {\n    const instance = this._exclusiveInstances.get(keysound)\n    if (instance) {\n      setTimeout(() => instance.stop(), delay * 1000)\n      this._exclusiveInstances.delete(keysound)\n    }\n  }\n}\n\nexport default WaveFactory\n","import * as touch3d from '../display/touch3d'\n\nimport bench from 'bemuse/devtools/benchmark'\n\nconst BUTTONS = [\n  'p1_1',\n  'p1_2',\n  'p1_3',\n  'p1_4',\n  'p1_5',\n  'p1_6',\n  'p1_7',\n  'start',\n]\n\nwindow.BEMUSE_TOUCH_STATS = []\n\nfunction StatsRecorder() {\n  const stats = []\n  window.BEMUSE_TOUCH_STATS.push(stats)\n  return {\n    record(input) {\n      for (const { x, y } of input) {\n        stats.push({ x: Math.round(x), y: Math.round(y) })\n      }\n    },\n    done() {\n      if (stats.length) {\n        localStorage['_stats_touch'] = JSON.stringify(window.BEMUSE_TOUCH_STATS)\n      }\n    },\n  }\n}\n\nexport function TouchPlugin(context) {\n  let scratchStartY = null\n  let scratchY = null\n  const getInput = bench.wrap('input:touch:I', _getInput)\n  const getScratch = bench.wrap('input:touch:SC', _getScratch)\n  const getButton = bench.wrap('input:touch:B', _getButton)\n  const getPinch = bench.wrap('input:touch:P', _getPinch)\n  const statsRecorder = new StatsRecorder()\n  const touch3dMode = context.skinData.displayMode === 'touch3d'\n  const pinchThreshold = touch3dMode ? touch3d.getRow(0.8).y : 550\n  return {\n    name: 'TouchPlugin',\n    get() {\n      const input = getInput()\n      const output = {}\n      if (bench.enabled) bench.stats['input:touch:n'] = '' + input.length\n      statsRecorder.record(input)\n      output['p1_SC'] = getScratch(input)\n      for (const button of BUTTONS) {\n        output[button] = getButton(input, button)\n      }\n      if (touch3dMode) {\n        for (const p of input) {\n          const lane = touch3d.getTouchedColumn(p.x, p.y)\n          if (lane) output['p1_' + lane] = 1\n        }\n      }\n      output['p1_pinch'] = getPinch(input)\n      return output\n    },\n    destroy() {\n      statsRecorder.done()\n    },\n  }\n  function _expand(rectangle, amount = 4) {\n    const newRect = rectangle.clone()\n    newRect.x -= amount\n    newRect.y -= amount\n    newRect.width += amount * 2\n    newRect.height += amount * 2\n    return newRect\n  }\n  function _getInput() {\n    return context.input\n  }\n  function _getButton(input, button) {\n    const objects = context.refs[button]\n    if (objects) {\n      for (const object of objects) {\n        const bounds = _expand(object.getBounds())\n        for (const p of input) {\n          if (bounds.contains(p.x, p.y)) return 1\n        }\n      }\n    }\n    return 0\n  }\n  function _getScratch(input) {\n    const objects = context.refs['p1_SC']\n    if (!objects) return 0\n    scratchY = null\n    for (const p of input) {\n      for (const object of objects) {\n        if (_expand(object.getBounds(), 32).contains(p.x, p.y)) {\n          scratchY = p.y\n          break\n        }\n      }\n      if (scratchY !== null) {\n        break\n      }\n    }\n    if (scratchY === null) {\n      scratchStartY = null\n      return 0\n    }\n    if (scratchStartY === null) {\n      scratchStartY = scratchY\n    }\n    if (scratchY > scratchStartY + 24) {\n      scratchStartY = scratchY - 24\n    } else if (scratchY < scratchStartY - 24) {\n      scratchStartY = scratchY + 24\n    }\n    return scratchY > scratchStartY + 4\n      ? -1\n      : scratchY < scratchStartY - 4\n      ? 1\n      : 0\n  }\n  function _getPinch(input) {\n    let a = null\n    let b = null\n    for (const p of input) {\n      if (p.y < pinchThreshold) {\n        if (a === null) {\n          a = p.y\n        } else if (b === null) {\n          b = p.y\n        } else {\n          return 0\n        }\n      }\n    }\n    if (a !== null && b !== null) {\n      return Math.abs(a - b)\n    } else {\n      return 0\n    }\n  }\n}\n\nexport default TouchPlugin\n","import * as ProgressUtils from 'bemuse/progress/utils'\nimport _ from 'lodash'\nimport defaultKeysoundCache from 'bemuse/keysound-cache'\nimport pMap from 'p-map'\nimport { EXTRA_FORMATTER } from 'bemuse/progress/formatters'\n\nexport class SamplesLoader {\n  constructor(assets, master, { keysoundCache = defaultKeysoundCache } = {}) {\n    this._assets = assets\n    this._master = master\n    this._keysoundCache = keysoundCache\n  }\n\n  loadFiles(files, loadProgress, decodeProgress) {\n    const onload = ProgressUtils.fixed(files.length, loadProgress)\n    const ondecode = ProgressUtils.fixed(files.length, decodeProgress)\n    const load = (name) =>\n      new Promise((resolve) => {\n        requestAnimationFrame(() => {\n          resolve(this._loadSample(name, onload, ondecode))\n        })\n      })\n    if (decodeProgress) decodeProgress.formatter = EXTRA_FORMATTER\n    return pMap(files, load, { concurrency: 64 }).then((arr) =>\n      _(arr).filter().fromPairs().value()\n    )\n  }\n\n  async _loadSample(name, onload, ondecode) {\n    const audioBufferPromise = (async () => {\n      if (this._keysoundCache.isCached(name)) {\n        const cache = await this._keysoundCache.get(name)\n        onload(name)\n        ondecode(name)\n        return cache\n      }\n      const file = await this._getFile(name)\n      const buffer = await file.read()\n      onload(name)\n      const audioBuffer = await this._decode(buffer)\n      this._keysoundCache.cache(name, audioBuffer)\n      ondecode(name)\n      return audioBuffer\n    })()\n    try {\n      const audioBuffer = await audioBufferPromise\n\n      const sample = await this._master.sample(audioBuffer)\n      return [name, sample]\n    } catch (e) {\n      console.error('Unable to load keysound: ' + name, e)\n      return null\n    }\n  }\n\n  _decode(buffer) {\n    return this._master.decode(buffer)\n  }\n\n  _getFile(name) {\n    name = name.replace(/\\\\/g, '/')\n    return this._assets\n      .file(name.replace(/\\.\\w+$/, '.ogg'))\n      .catch(() => this._assets.file(name.replace(/\\.\\w+$/, '.m4a')))\n      .catch(() => this._assets.file(name.replace(/\\.\\w+$/, '.flac')))\n      .catch(() => this._assets.file(name.replace(/\\.\\w+$/, '.mp3')))\n      .catch(() => this._assets.file(name))\n  }\n}\n\nexport default SamplesLoader\n","import invariant from 'invariant'\n\nexport function createKeysoundCache() {\n  const map = new Map()\n  let _lastSongId\n  return {\n    receiveSongId(nextSongId) {\n      if (_lastSongId !== nextSongId) {\n        _lastSongId = nextSongId\n        map.clear()\n      }\n    },\n    isEmpty() {\n      return map.size === 0\n    },\n    isCached(soundName) {\n      return map.has(soundName)\n    },\n    cache(soundName, audioBuffer) {\n      invariant(_lastSongId, 'Expected current song to be set.')\n      map.set(soundName, audioBuffer)\n    },\n    get(soundName) {\n      return map.get(soundName)\n    },\n  }\n}\n\nexport default createKeysoundCache\n","import createKeysoundCache from './createKeysoundCache'\n\nexport default createKeysoundCache()\n","import Progress from 'bemuse/progress'\nimport * as ProgressUtils from 'bemuse/progress/utils'\nimport readBlob from 'bemuse/utils/read-blob'\nimport _ from 'lodash'\nimport throat from 'throat'\nimport { IResource, IResources } from './types'\nimport { URLResources } from './url'\n\ntype MetadataFileJSON = {\n  files: BemusePackFileEntry[]\n  refs: BemusePackRefEntry[]\n}\ntype BemusePackRefEntry = { path: string; hash: string }\ntype BemusePackFileEntry = { name: string; ref: BemusePackContentRef }\ntype BemusePackContentRef = [number, number, number]\n\nexport class BemusePackageResources implements IResources {\n  private _base: IResources\n  private _fallback: IResources | undefined\n  private _fallbackPattern: RegExp | undefined\n  private _metadataFilename: string\n  public loadPayload: (\n    resourcePromise: PromiseLike<IResource>\n  ) => PromiseLike<Blob>\n\n  public progress = {\n    all: new Progress(),\n    current: new Progress(),\n  }\n\n  constructor(\n    base: string | IResources,\n    options: {\n      metadataFilename?: string\n      fallback?: string | IResources\n      fallbackPattern?: RegExp\n    } = {}\n  ) {\n    if (typeof base === 'string') {\n      base = new URLResources(new URL(base, location.href))\n    }\n\n    const fallback =\n      typeof options.fallback === 'string'\n        ? new URLResources(new URL(options.fallback, location.href))\n        : options.fallback\n\n    this._base = base\n    this._fallback = fallback\n    this._fallbackPattern = options.fallbackPattern\n    this._metadataFilename = options.metadataFilename || 'metadata.json'\n\n    const simultaneous = ProgressUtils.simultaneous(this.progress.current)\n    const nextProgress = () => {\n      const progress = new Progress()\n      simultaneous.add(progress)\n      return progress\n    }\n    this.loadPayload = ProgressUtils.wrapPromise(\n      this.progress.all,\n      throat(2, (resourcePromise) =>\n        resourcePromise\n          .then((resource) => resource.read(nextProgress()))\n          .then((arrayBuffer) => new Blob([arrayBuffer]))\n          .then(getPayload)\n      )\n    )\n  }\n\n  private _getMetadata = _.once(async () => {\n    const file = await this._base.file(this._metadataFilename)\n    const data = await file.read()\n    const text = await new Blob([data]).text()\n    return JSON.parse(text) as MetadataFileJSON\n  })\n\n  private _getRefs = _.once(async () => {\n    const metadata = await this._getMetadata()\n    return metadata.refs.map((spec) => new Ref(this, spec))\n  })\n\n  private _getFileMap = _.once(async () => {\n    const metadata = await this._getMetadata()\n    const files = new Map<string, BemusePackFileEntry>()\n    for (const file of metadata.files) {\n      files.set(file.name.toLowerCase(), file)\n    }\n    return files\n  })\n\n  get base() {\n    return this._base\n  }\n\n  async file(name: string): Promise<IResource> {\n    const fileMap = await this._getFileMap()\n    const file = fileMap.get(name.toLowerCase())\n    if (file) {\n      return new BemusePackageFileResource(this, file.ref, file.name)\n    } else if (\n      this._fallback &&\n      this._fallbackPattern &&\n      this._fallbackPattern.test(name)\n    ) {\n      return this._fallback.file(name)\n    } else {\n      throw new Error('Unable to find: ' + name)\n    }\n  }\n\n  async getBlob([index, start, end]: [number, number, number]) {\n    const refs = await this._getRefs()\n    const ref = refs[index]\n    const payload = await ref.load()\n    return payload.slice(start, end)\n  }\n}\n\nclass BemusePackageFileResource implements IResource {\n  constructor(\n    private resources: BemusePackageResources,\n    private ref: BemusePackContentRef,\n    public readonly name: string\n  ) {}\n\n  read(progress: Progress): PromiseLike<ArrayBuffer> {\n    return ProgressUtils.atomic(\n      progress,\n      this.resources\n        .getBlob(this.ref)\n        .then((blob) => readBlob(blob).as('arraybuffer'))\n    )\n  }\n\n  async resolveUrl() {\n    const blob = await this.resources.getBlob(this.ref)\n    return URL.createObjectURL(blob)\n  }\n}\n\nclass Ref {\n  private _basePromise: PromiseLike<IResource>\n  private _promise: PromiseLike<Blob> | undefined\n  constructor(\n    private resources: BemusePackageResources,\n    spec: BemusePackRefEntry\n  ) {\n    this._basePromise = resources.base.file(spec.path)\n  }\n\n  load() {\n    return (\n      this._promise ||\n      (this._promise = this.resources.loadPayload(this._basePromise))\n    )\n  }\n}\n\nexport default BemusePackageResources\n\nasync function getPayload(blob: Blob) {\n  const magic = await readBlob(blob.slice(0, 10)).as('text')\n  if (magic !== 'BEMUSEPACK') {\n    throw new Error('Invalid magic number')\n  }\n  const buffer = await readBlob(blob.slice(10, 14)).as('arraybuffer')\n  const array = new Uint8Array(buffer)\n  const length =\n    array[0] + (array[1] << 8) + (array[2] << 16) + (array[3] << 24)\n  const metadataLength = length\n  return blob.slice(14 + metadataLength)\n}\n","import defaultAudioContext from 'bemuse/audio-context'\nimport readBlob from 'bemuse/utils/read-blob'\nimport { decodeOGG } from './ogg'\n\nexport const FADE_LENGTH = 0.001\n\nconst dummyAudioTag = document.createElement('audio')\n// Checks whether an audio format is supported.\nexport function canPlay(type) {\n  // We have a Vorbis audio decoder!\n  if (type === 'audio/ogg; codecs=\"vorbis\"') return true\n  return dummyAudioTag.canPlayType(type) === 'probably'\n}\n\nconst needsVorbisDecoder = !dummyAudioTag.canPlayType(\n  'audio/ogg; codecs=\"vorbis\"'\n)\n\n// The sampling master is a wrapper class around Web Audio API\n// that takes care of:\n//\n// - Decoding audio from an ArrayBuffer or Blob (resulting in a \"Sample\").\n// - Playing the `Sample` and managing its lifecycle.\nexport class SamplingMaster {\n  constructor(audioContext) {\n    this._audioContext = audioContext || defaultAudioContext\n    this._samples = []\n    this._groups = []\n    this._instances = new Set()\n    this._destination = this._audioContext.destination\n  }\n\n  // Connects a dummy node to the audio, thereby unmuting the audio system on\n  // iOS devices (which keeps the audio muted until a user interacts with the\n  // page).\n  unmute() {\n    unmuteAudio(this._audioContext)\n  }\n\n  // The underlying AudioContext.\n  get audioContext() {\n    return this._audioContext\n  }\n\n  // The audio destination.\n  get destination() {\n    return this._destination\n  }\n\n  // The current time\n  // See: https://webaudio.github.io/web-audio-api/#dom-baseaudiocontext-currenttime\n  get currentTime() {\n    return this._audioContext.currentTime\n  }\n\n  // Destroys this SamplingMaster, make it unusable.\n  destroy() {\n    if (this._destroyed) return\n    this._destroyed = true\n    for (const sample of this._samples) sample.destroy()\n    for (const instance of this._instances) instance.destroy()\n    this._samples = null\n    this._instances = null\n  }\n\n  // Decodes the audio data from a Blob or an ArrayBuffer.\n  // Returns an AudioBuffer which can be re-used in other sampling masters.\n  decode(blobOrArrayBuffer) {\n    return this._coerceToArrayBuffer(blobOrArrayBuffer).then((arrayBuffer) =>\n      this._decodeAudio(arrayBuffer)\n    )\n  }\n\n  // Creates a `Sample` from a Blob or an ArrayBuffer or an AudioBuffer.\n  sample(blobOrArrayBufferOrAudioBuffer) {\n    const audioBufferPromise = (() => {\n      if (blobOrArrayBufferOrAudioBuffer.numberOfChannels) {\n        return Promise.resolve(blobOrArrayBufferOrAudioBuffer)\n      } else {\n        return this.decode(blobOrArrayBufferOrAudioBuffer)\n      }\n    })()\n    return audioBufferPromise.then((audioBuffer) => {\n      if (this._destroyed) throw new Error('SamplingMaster already destroyed!')\n      const sample = new Sample(this, audioBuffer)\n      this._samples.push(sample)\n      return sample\n    })\n  }\n\n  group(options) {\n    const group = new SoundGroup(this, options)\n    this._groups.push(group)\n    return group\n  }\n\n  _coerceToArrayBuffer(blobOrArrayBuffer) {\n    if (blobOrArrayBuffer instanceof ArrayBuffer) {\n      return Promise.resolve(blobOrArrayBuffer)\n    } else {\n      return readBlob(blobOrArrayBuffer).as('arraybuffer')\n    }\n  }\n\n  _decodeAudio(arrayBuffer) {\n    return new Promise((resolve, reject) => {\n      if (needsVorbisDecoder && arrayBuffer.byteLength > 4) {\n        const view = new Uint8Array(arrayBuffer, 0, 4)\n        if (\n          view[0] === 0x4f &&\n          view[1] === 0x67 &&\n          view[2] === 0x67 &&\n          view[3] === 0x53\n        ) {\n          return resolve(decodeOGG(this.audioContext, arrayBuffer))\n        }\n      }\n      this.audioContext.decodeAudioData(\n        arrayBuffer,\n        function decodeAudioDataSuccess(audioBuffer) {\n          resolve(audioBuffer)\n        },\n        function decodeAudioDataFailure(e) {\n          reject(new Error('Unable to decode audio: ' + e))\n        }\n      )\n    })\n  }\n\n  _startPlaying(instance) {\n    this._instances.add(instance)\n  }\n\n  _stoppedPlaying(instance) {\n    this._instances.delete(instance)\n  }\n}\n\n// Sound group\nexport class SoundGroup {\n  constructor(samplingMaster, { volume } = {}) {\n    this._master = samplingMaster\n    this._gain = this._master.audioContext.createGain()\n    if (volume != null) this._gain.gain.value = volume\n    this._gain.connect(this._master.destination)\n  }\n\n  get destination() {\n    return this._gain\n  }\n\n  destroy() {\n    this._gain.disconnect()\n    this._gain = null\n  }\n}\n\n// The Sample is created by and belongs to the `SamplingMaster`.\n//\n// You don't invoke this constructor directly; it is invoked by\n// `SamplingMaster#create`.\nexport class Sample {\n  constructor(samplingMaster, /** @type {AudioBuffer} */ audioBuffer) {\n    this._master = samplingMaster\n    this._buffer = audioBuffer\n  }\n\n  // Plays the sample and returns the new PlayInstance.\n  play(delay, options) {\n    return new PlayInstance(this._master, this._buffer, delay, options)\n  }\n\n  // Destroys this sample, thereby making it unusable.\n  destroy() {\n    this._master = null\n    this._buffer = null\n  }\n\n  get duration() {\n    return this._buffer.duration\n  }\n}\n\n// When a `Sample` is played, a PlayInstance is created.\n// A PlayInstance may not be reused; after the sound finishes playing,\n// you have to invoke `Sample#play` again.\n//\n// You don't invoke this constructor directly; it is invoked by `Sample#play`.\nexport class PlayInstance {\n  constructor(samplingMaster, buffer, delay, options = {}) {\n    delay = delay || 0\n    this._master = samplingMaster\n\n    // Connect all the stuff...\n    const context = samplingMaster.audioContext\n    const source = context.createBufferSource()\n    source.buffer = buffer\n    source.onended = () => this.stop()\n    const gain = context.createGain()\n    source.connect(gain)\n    const destination =\n      options.node ||\n      (options.group && options.group.destination) ||\n      samplingMaster.destination\n    gain.connect(destination)\n    this._source = source\n    this._gain = this.TEST_node = gain\n\n    // Start the sound.\n    const startTime = !delay ? 0 : Math.max(0, context.currentTime + delay)\n    const startOffset = options.start || 0\n    const fadeIn = startOffset > 0\n    let fadeOutAt = false\n    if (fadeIn) {\n      gain.gain.setValueAtTime(0, 0)\n    }\n    if (options.end !== undefined) {\n      const duration = Math.max(options.end - startOffset, 0)\n      source.start(startTime, startOffset, duration + FADE_LENGTH)\n      fadeOutAt = context.currentTime + delay + duration\n    } else {\n      source.start(startTime, startOffset)\n    }\n    if (fadeIn) {\n      gain.gain.setValueAtTime(0, context.currentTime + delay)\n      gain.gain.linearRampToValueAtTime(\n        1,\n        context.currentTime + delay + FADE_LENGTH\n      )\n    }\n    if (fadeOutAt !== false) {\n      gain.gain.setValueAtTime(1, fadeOutAt)\n      gain.gain.linearRampToValueAtTime(0, fadeOutAt + FADE_LENGTH)\n    }\n    this._master._startPlaying(this)\n  }\n\n  // Stops the sample and disconnects the underlying Web Audio nodes.\n  stop() {\n    if (!this._source) return\n    this._source.stop(0)\n    this._source.disconnect()\n    this._gain.disconnect()\n    this._source = null\n    this._gain = null\n    this._master._stoppedPlaying(this)\n    if (this.onstop) this.onstop()\n  }\n\n  // Makes this PlayInstance sound off-pitch, as a result of badly hitting\n  // a note.\n  bad() {\n    if (!this._source) return\n    this._source.playbackRate.value =\n      Math.random() < 0.5 ? Math.pow(2, 1 / 24) : Math.pow(2, -1 / 24)\n  }\n\n  // Destroys this PlayInstance.\n  destroy() {\n    this.stop()\n  }\n}\n\nexport default SamplingMaster\n\n/**\n * Enables Web Audio on iOS. By default, on iOS, audio is disabled.\n * This function must be called before audio will start working. It must be\n * called as a response to some user interaction (e.g. touchstart).\n *\n * Also, there’s now Chrome autoplay policy taking effect.\n * https://developers.google.com/web/updates/2017/09/autoplay-policy-changes\n *\n * @param {AudioContext} ctx The AudioContext to be unmuted.\n */\nexport function unmuteAudio(ctx = defaultAudioContext) {\n  // Perform some strange magic to unmute the audio on iOS devices.\n  // This code doesn’t make sense at all, you know.\n  const gain = ctx.createGain()\n  const osc = ctx.createOscillator()\n  osc.frequency.value = 440\n  osc.start(ctx.currentTime + 0.1)\n  osc.stop(ctx.currentTime + 0.1)\n  gain.connect(ctx.destination)\n  gain.disconnect()\n\n  resumeContext(ctx).catch((e) => {\n    console.error('[sampling-master] Cannot resume AudioContext', e)\n  })\n}\n\nasync function resumeContext(ctx) {\n  return ctx.resume()\n}\n","import throat from 'throat'\n\ntype OGGDecodeEvent = {\n  data?: Float32Array[]\n  sampleRate: number\n  error?: any\n  eof?: boolean\n}\n\ntype OGGDecoder = {\n  decode(arrayBuffer: ArrayBuffer, callback: (e: OGGDecodeEvent) => void): void\n}\n\nlet decoderPromise: Promise<OGGDecoder>\n\nconst limit = throat(1)\n\nfunction getDecoder() {\n  if (!decoderPromise) {\n    decoderPromise = import(\n      // @ts-ignore\n      /* webpackChunkName: 'stbvorbis' */ './vendor/stbvorbis/stbvorbis-e6da5fe-NDEBUG.js?raw'\n    )\n      .then((ns) => ns.default)\n      .then((src) => {\n        // eslint-disable-next-line no-eval\n        return (0, eval)(src + 'stbvorbis')\n      })\n  }\n  return decoderPromise\n}\n\n/**\n * Decodes an OGG file using stbvorbis.js.\n */\nexport async function decodeOGG(\n  audioContext: AudioContext,\n  arrayBuffer: ArrayBuffer\n) {\n  const stbvorbis = await getDecoder()\n  return limit(() => doDecodeOGG(stbvorbis, audioContext, arrayBuffer))\n}\n\nfunction doDecodeOGG(\n  stbvorbis: OGGDecoder,\n  audioContext: AudioContext,\n  arrayBuffer: ArrayBuffer\n) {\n  return new Promise<AudioBuffer>((resolve, reject) => {\n    const buffers: Float32Array[][] = []\n    let totalLength = 0\n    let sampleRate: number\n    stbvorbis.decode(arrayBuffer, function (e) {\n      if (e.data) {\n        sampleRate = e.sampleRate\n        buffers.push(e.data)\n        totalLength += e.data[0].length\n      }\n      if (e.error) {\n        const error =\n          e.error instanceof Error ? e.error : `stbvorbis.js Error: ${e.error}`\n        reject(error)\n      }\n      if (e.eof) {\n        resolve(createBuffer(audioContext, buffers, totalLength, sampleRate))\n      }\n    })\n  })\n}\n\nasync function createBuffer(\n  audioContext: AudioContext,\n  decodedChunks: Float32Array[][],\n  length: number,\n  sampleRate: number\n) {\n  if (!length) throw new Error(`stbvorbis.js Error: No length`)\n  if (!sampleRate) throw new Error(`stbvorbis.js Error: No sample rate`)\n  const numberOfChannels = decodedChunks[0].length\n  const audioBuffer = audioContext.createBuffer(\n    numberOfChannels,\n    length,\n    sampleRate\n  )\n  const channels: ChannelDataWriter[] = Array(audioBuffer.numberOfChannels)\n    .fill(null)\n    .map((_, ch) => new ChannelDataWriter(audioBuffer.getChannelData(ch)))\n  for (const chunk of decodedChunks) {\n    chunk.forEach((audioSamples, channelIndex) => {\n      channels[channelIndex].write(audioSamples)\n    })\n  }\n  return audioBuffer\n}\n\nclass ChannelDataWriter {\n  private offset = 0\n  constructor(private data: Float32Array) {}\n  write(audioSamples: Float32Array) {\n    // iOS Safari does not support `buf.copyToChannel(a, ch, track[ch])`, so we had to copy audio data sample-by-sample.\n    const { offset, data } = this\n    for (let i = 0; i < audioSamples.length; i++) {\n      data[i + offset] = audioSamples[i]\n    }\n    this.offset += audioSamples.length\n  }\n}\n"],"names":["AudioContext","latencyHint","autoplayer","array","i","next","time","out","length","push","constructor","player","samples","master","waveFactory","volume","notechart","this","_waveFactory","keysounds","_autos","autos","_notes","notes","_played","Map","_autosound","options","autosound","update","state","_playAutokeysounds","_playAutosounds","_handleSoundNotifications","notifications","sounds","auto","playAuto","autosounds","poor","stats","note","_hitNote","soundNotifications","notification","type","judgment","_breakNote","playFree","delay","instance","get","playNote","set","bad","stop","map","_master","_samples","_map","_exclusiveInstances","_group","group","slice","_play","exclusive","keysound","_stopOldExclusiveSound","filename","toLowerCase","sample","play","start","keysoundStart","end","keysoundEnd","setTimeout","delete","BUTTONS","StatsRecorder","window","BEMUSE_TOUCH_STATS","record","input","x","y","Math","round","done","localStorage","JSON","stringify","context","scratchStartY","scratchY","getInput","getScratch","objects","refs","p","object","_expand","getBounds","contains","getButton","button","bounds","getPinch","a","b","pinchThreshold","abs","statsRecorder","touch3dMode","skinData","displayMode","name","output","lane","destroy","rectangle","amount","newRect","clone","width","height","assets","keysoundCache","_assets","_keysoundCache","loadFiles","files","loadProgress","decodeProgress","onload","ondecode","formatter","Promise","resolve","requestAnimationFrame","_loadSample","concurrency","then","arr","filter","fromPairs","value","async","audioBufferPromise","isCached","cache","file","_getFile","buffer","read","audioBuffer","_decode","e","console","error","decode","replace","catch","_lastSongId","receiveSongId","nextSongId","clear","isEmpty","size","soundName","has","BemusePackageFileResource","resources","ref","progress","getBlob","blob","as","URL","createObjectURL","Ref","spec","_basePromise","base","path","load","_promise","loadPayload","getPayload","Error","Uint8Array","metadataLength","all","current","_getMetadata","_base","_metadataFilename","data","text","Blob","parse","_getRefs","_getFileMap","metadata","location","href","fallback","_fallback","_fallbackPattern","fallbackPattern","metadataFilename","simultaneous","resourcePromise","resource","add","nextProgress","arrayBuffer","test","index","FADE_LENGTH","dummyAudioTag","document","createElement","needsVorbisDecoder","canPlayType","SoundGroup","samplingMaster","_gain","audioContext","createGain","gain","connect","destination","disconnect","Sample","_buffer","PlayInstance","duration","source","createBufferSource","onended","node","_source","TEST_node","startTime","max","currentTime","startOffset","fadeIn","fadeOutAt","setValueAtTime","undefined","linearRampToValueAtTime","_startPlaying","_stoppedPlaying","onstop","playbackRate","random","pow","unmuteAudio","ctx","osc","createOscillator","frequency","resume","resumeContext","_audioContext","_groups","_instances","Set","_destination","unmute","_destroyed","blobOrArrayBuffer","_coerceToArrayBuffer","_decodeAudio","blobOrArrayBufferOrAudioBuffer","numberOfChannels","ArrayBuffer","reject","byteLength","view","decodeAudioData","decoderPromise","limit","decodeOGG","stbvorbis","ns","default","src","eval","buffers","sampleRate","totalLength","eof","decodedChunks","createBuffer","channels","Array","fill","_","ch","ChannelDataWriter","getChannelData","chunk","forEach","audioSamples","channelIndex","write","doDecodeOGG","offset"],"sourceRoot":""}