{"version":3,"sources":["file:///home/circleci/bemuse/src/utils/read-blob.js","file:///home/circleci/bemuse/packages/bms/lib/index.js","file:///home/circleci/bemuse/src/progress/utils.js","file:///home/circleci/bemuse/packages/bms/lib/time-signatures/index.js","file:///home/circleci/bemuse/packages/bms/lib/bms/objects.js","file:///home/circleci/bemuse/packages/bms/lib/bms/headers.js","file:///home/circleci/bemuse/packages/bms/lib/util/match.js","file:///home/circleci/bemuse/packages/bms/lib/spacing/index.js","file:///home/circleci/bemuse/packages/bms/lib/positioning/index.js","file:///home/circleci/bemuse/packages/bms/lib/keysounds/index.js","file:///home/circleci/bemuse/packages/bms/lib/song-info/index.js","file:///home/circleci/bemuse/packages/bms/lib/timing/index.js","file:///home/circleci/bemuse/packages/bms/lib/notes/channels.js","file:///home/circleci/bemuse/packages/bms/lib/notes/note.js","file:///home/circleci/bemuse/packages/bms/lib/notes/index.js","file:///home/circleci/bemuse/packages/bms/lib/speedcore/segment.js","file:///home/circleci/bemuse/packages/bms/lib/compiler/index.js","file:///home/circleci/bemuse/packages/bms/lib/reader/getReaderOptionsFromFilename.js","file:///home/circleci/bemuse/packages/bms/lib/reader/index.web.js","file:///home/circleci/bemuse/packages/bms/lib/bms/chart.js","file:///home/circleci/bemuse/packages/bms/lib/speedcore/index.js","file:///home/circleci/bemuse/src/progress/formatters.js","file:///home/circleci/bemuse/packages/bms/lib/util/lodash.js"],"names":["__webpack_exports__","blob","as","type","Promise","resolve","reject","reader","FileReader","onload","result","onerror","Error","readAsArrayBuffer","readAsText","__importStar","this","mod","__esModule","k","Object","hasOwnProperty","call","defineProperty","exports","value","Reader","__webpack_require__","Compiler","chart_1","BMSChart","headers_1","BMSHeaders","objects_1","BMSObjects","speedcore_1","Speedcore","time_signatures_1","TimeSignatures","notes_1","Notes","timing_1","Timing","song_info_1","SongInfo","keysounds_1","Keysounds","positioning_1","Positioning","spacing_1","Spacing","fixed","total","progress","loaded","report","extra","atomic","promise","tap","data","byteLength","formatter","bemuse_progress_formatters__WEBPACK_IMPORTED_MODULE_0__","wrapPromise","f","current","apply","arguments","bind","from","to","watch","simultaneous","target","queue","unsubscribe","update","length","shift","add","push","_values","prototype","set","measure","get","getBeats","measureToBeat","fraction","sum","i","_objects","object","channel","test","all","slice","allSorted","list","sort","a","b","_data","_dataAll","each","callback","name","toLowerCase","getAll","key","match","text","matched","when","pattern","else","segments","_speedcore","factor","beat","x","fromBMSChart","chart","objects","forEach","headers","isNaN","previous","dx","t","inclusive","unshift","speed","position","lodash_1","map","_map","id","files","uniq","values","match_1","info","title","artist","genre","subtitles","subartists","difficulty","level","assign","extractSubtitle","m","precedence","bpm","stop","initialBPM","actions","state","seconds","action","stopBeats","_eventBeats","beatToSeconds","secondsToBeat","bpmAtBeat","segmentAtX","getEventBeats","parseInt","IIDX_P1","11","12","13","14","15","18","19","16","__importDefault","default","data_structure_1","Note","endBeat","maybe","column","keysound","note_1","invariant_1","ChannelMapping","notes","_notes","count","options","mapping","CHANNEL_MAPPING","BMSNoteBuilder","build","_chart","_mapping","_activeLN","_lastNote","_lnObj","_channelMapping","_handle","_handleNormalNote","charAt","_handleLongNote","_normalizeChannel","_getBeat","note","undefined","_getColumn","replace","Segment","matchers","bms","random","if","endif","timeSignature","header","dtx","compile","rng","max","Math","floor","matcher","format","randomStack","skipStack","headerSentences","channelSentences","controlSentences","skippedSentences","malformedSentences","warnings","split","line","trim","index","eachLine","lineNumber","flow","pop","skipped","timeSignatures","string","items","substr","handleChannelSentence","message","warn","getReaderOptionsFromFilename","filename","forceEncoding","chardet","read","buffer","readAsync","charset","detect","Blob","getReaderOptionsFromFilename_1","segment_1","_segments","_reached","typeFn","segment","_segmentAt","X","segmentAtT","T","wrap","BYTES_FORMATTER","bytes__WEBPACK_IMPORTED_MODULE_0___default","PERCENTAGE_FORMATTER","toFixed","EXTRA_FORMATTER","lodash_uniq_1","lodash_map_1","lodash_values_1","lodash_assign_1"],"mappings":"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","file":"app~comingSoonDemo~game~playground~test-2c9e7b066fdc4a7b924c.js","sourcesContent":["export default readBlob\n\n// Reads the blob as a specified type. The blob will not actually be read\n// unless the ``as()`` method is called.\n//\n// .. js:function:: as(type)\n//\n//    Starts reading the blob as ``type``. The ``type`` is a String such as\n//    \"arraybuffer\" or \"text\".\nexport function readBlob (blob) {\n  return {\n    as (type) {\n      return new Promise(function (resolve, reject) {\n        let reader = new FileReader()\n        reader.onload = function () {\n          resolve(reader.result)\n        }\n        reader.onerror = function () {\n          reject(new Error('Unable to read from Blob'))\n        }\n        switch (type) {\n          case 'arraybuffer':\n            reader.readAsArrayBuffer(blob)\n            break\n          case 'text':\n            reader.readAsText(blob)\n            break\n        }\n      })\n    }\n  }\n}\n","\"use strict\";\n/**\n * Public: The `bms` package is a library for working with rhythm game data.\n *\n * Although this library’s name suggests that it is for BMS file format,\n * almost every part can be used standalone.\n *\n * This package contains:\n *\n * - __Modules that reads and parses BMS files:__\n *\n *   - {Reader} reads the BMS file from a {Buffer}, detects the character set\n *     and decodes the buffer using that character set into a {String}.\n *   - {Compiler} reads the BMS source from a {String}, and converts into\n *     {BMSChart}, an internal representation of a BMS notechart.\n *\n * - __Classes for representing a BMS notechart.__\n *   These module stores the data as close to the BMS file format as possible.\n *\n *   Almost no musical interpretation is made.\n *   For example, a BPM change is simply represented using a\n *   BMSObject with `channel` = `03` or `08`.\n *\n *   - {BMSChart} is composed of {BMSHeaders}, {BMSObjects}, and {TimeSignatures}.\n *   - {BMSHeaders} represents the header sentences in a BMS file.\n *   - {BMSObjects} represents the objects in a BMS file.\n *   - {BMSObject} represents a single object.\n *\n * - __Classes that represent different aspects of a notechart.__\n *   Instance of these classes may be created from a {BMSChart},\n *   but they can be used in a standalone manner as well.\n *\n *   This makes this library very flexible,\n *   and able to accommodate different formats of notechart.\n *   For example, see the [bmson](https: *github.com/bemusic/bmson) package.\n *\n *   It’s also possible to use these classes in context other than music gaming,\n *   for example, you can use these classes to help building a music player\n *   that requires precise synchronization between beats.\n *\n *   - {TimeSignatures} represents a collection of time signatures\n *     in a musical score, and lets you convert the measure number and fraction\n *     into beat number.\n *   - {Timing} represents the timing information in a musical score,\n *     and provides methods to convert between musical time (beats) and\n *     metric time (seconds).\n *   - {SongInfo} represents the basic song information,\n *     such as title, artist, and genre.\n *   - {Notes} represents the sound objects inside your notechart.\n *   - {Keysounds} represents a mapping between keysound ID and filename.\n *   - {Positioning} represents a mapping between beat and in-game position.\n *     Some rhythm game lets chart author control the amount of scrolling\n *     per beat. In StepMania 5, this is called the scroll segments.\n *   - {Spacing} represents a mapping between beat and note spacing.\n *     Some rhythm game lets chart author change the note spacing (HI-SPEED)\n *     dynamically. In StepMania 5, this is called the speed segments.\n *\n * - __Low-level utility classes:__\n *\n *   - {Speedcore} represents a linear animation.\n */\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Reader = __importStar(require(\"./reader\"));\nexports.Reader = Reader;\nvar Compiler = __importStar(require(\"./compiler\"));\nexports.Compiler = Compiler;\nvar chart_1 = require(\"./bms/chart\");\nexports.BMSChart = chart_1.BMSChart;\nvar headers_1 = require(\"./bms/headers\");\nexports.BMSHeaders = headers_1.BMSHeaders;\nvar objects_1 = require(\"./bms/objects\");\nexports.BMSObjects = objects_1.BMSObjects;\nvar speedcore_1 = require(\"./speedcore\");\nexports.Speedcore = speedcore_1.Speedcore;\nvar time_signatures_1 = require(\"./time-signatures\");\nexports.TimeSignatures = time_signatures_1.TimeSignatures;\nvar notes_1 = require(\"./notes\");\nexports.Notes = notes_1.Notes;\nvar timing_1 = require(\"./timing\");\nexports.Timing = timing_1.Timing;\nvar song_info_1 = require(\"./song-info\");\nexports.SongInfo = song_info_1.SongInfo;\nvar keysounds_1 = require(\"./keysounds\");\nexports.Keysounds = keysounds_1.Keysounds;\nvar positioning_1 = require(\"./positioning\");\nexports.Positioning = positioning_1.Positioning;\nvar spacing_1 = require(\"./spacing\");\nexports.Spacing = spacing_1.Spacing;\n//# sourceMappingURL=index.js.map","import { BYTES_FORMATTER } from 'bemuse/progress/formatters'\n\nexport function fixed (total, progress) {\n  if (!progress) return () => {}\n  let loaded = 0\n  progress.report(0, total)\n  return extra => progress.report(++loaded, total, extra)\n}\n\n// Reports the progress as an atomic operation.\nexport function atomic (progress, promise) {\n  if (!progress) return promise\n  return Promise.resolve(promise).tap(data => {\n    if (data && data.byteLength) {\n      progress.formatter = BYTES_FORMATTER\n      progress.report(data.byteLength, data.byteLength)\n    } else {\n      progress.report(1, 1)\n    }\n  })\n}\n\nexport function wrapPromise (progress, f) {\n  let current = 0\n  let total = 0\n  return function () {\n    progress.report(current, ++total)\n    return Promise.resolve(f.apply(this, arguments)).tap(() =>\n      progress.report(++current, total)\n    )\n  }\n}\n\nexport function bind (from, to) {\n  return from.watch(() => to.report(from.current, from.total, from.extra))\n}\n\nexport function simultaneous (target) {\n  let queue = []\n  let current\n  let unsubscribe\n  function update () {\n    if (current) {\n      target.report(current.current, current.total, current.extra)\n    }\n    if (queue.length > 0 && (!current || current.progress >= 1)) {\n      bind(queue.shift())\n    }\n  }\n  function bind (progress) {\n    if (current === progress) {\n      return\n    }\n    if (unsubscribe) {\n      unsubscribe()\n      unsubscribe = null\n    }\n    current = progress\n    if (current) {\n      unsubscribe = current.watch(update)\n    }\n  }\n  return {\n    add (progress) {\n      queue.push(progress)\n      update()\n    }\n  }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * A TimeSignatures is a collection of time signature values\n * index by measure number.\n *\n * The measure number starts from 0.\n * By default, each measure has a measure size of 1\n * (which represents the common 4/4 time signature)\n *\n * ## Example\n *\n * If you have a BMS like this:\n *\n * ```\n * #00102:0.75\n * #00103:1.25\n * ```\n *\n * Having parsed it using a {Compiler} into a {BMSChart},\n * you can access the {TimeSignatures} object:\n *\n * ```js\n * var timeSignatures = bmsChart.timeSignatures\n * ```\n *\n * Note that you can also use the constructor\n * to create a {TimeSignatures} from scratch.\n *\n * One of the most useful use case of this class\n * is to convert the measure and fraction into beat number.\n *\n * ```js\n * timeSignatures.measureToBeat(0, 0.000) // =>  0.0\n * timeSignatures.measureToBeat(0, 0.500) // =>  2.0\n * timeSignatures.measureToBeat(1, 0.000) // =>  4.0\n * timeSignatures.measureToBeat(1, 0.500) // =>  5.5\n * timeSignatures.measureToBeat(2, 0.000) // =>  7.0\n * timeSignatures.measureToBeat(2, 0.500) // =>  9.5\n * timeSignatures.measureToBeat(3, 0.000) // => 12.0\n * ```\n */\nvar TimeSignatures = /** @class */ (function () {\n    function TimeSignatures() {\n        this._values = {};\n    }\n    /**\n     * Sets the size of a specified measure.\n     * @param {number} measure the measure number, starting from 0\n     * @param {number} value the measure size.\n     *  For example, a size of 1.0 represents a common 4/4 time signature,\n     *  whereas a size of 0.75 represents the 3/4 or 6/8 time signature.\n     */\n    TimeSignatures.prototype.set = function (measure, value) {\n        this._values[measure] = value;\n    };\n    /**\n     * Retrieves the size of a specified measure.\n     * @param {number} measure representing the measure number.\n     * @returns {number} the size of the measure.\n     *  By default, a measure has a size of 1.\n     */\n    TimeSignatures.prototype.get = function (measure) {\n        return this._values[measure] || 1;\n    };\n    /**\n     * Retrieves the number of beats in a specified measure.\n     *\n     * Since one beat is equivalent to a quarter note in 4/4 time signature,\n     * this is equivalent to `(timeSignatures.get(measure) * 4)`.\n     * @param {number} measure representing the measure number.\n     * @returns {number} the size of the measure in beats.\n     */\n    TimeSignatures.prototype.getBeats = function (measure) {\n        return this.get(measure) * 4;\n    };\n    /**\n     * Converts a measure number and a fraction inside that measure\n     * into the beat number.\n     *\n     * @param {number} measure the measure number.\n     * @param {number} fraction the fraction of a measure,\n     * @returns the number of beats since measure 0.\n     */\n    TimeSignatures.prototype.measureToBeat = function (measure, fraction) {\n        var sum = 0;\n        for (var i = 0; i < measure; i++)\n            sum += this.getBeats(i);\n        return sum + this.getBeats(measure) * fraction;\n    };\n    return TimeSignatures;\n}());\nexports.TimeSignatures = TimeSignatures;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * BMSObjects holds a collection of objects inside a BMS notechart.\n */\nvar BMSObjects = /** @class */ (function () {\n    function BMSObjects() {\n        /** @type {BMSObject[]} */\n        this._objects = [];\n    }\n    /**\n     * Adds a new object to this collection.\n     * If an object already exists on the same channel and position,\n     * the object is replaced (except for autokeysound tracks).\n     * @param {BMSObject} object the object to add\n     */\n    BMSObjects.prototype.add = function (object) {\n        if (object.channel !== '01') {\n            for (var i = 0; i < this._objects.length; i++) {\n                var test = this._objects[i];\n                if (test.channel === object.channel &&\n                    test.measure === object.measure &&\n                    test.fraction === object.fraction) {\n                    this._objects[i] = object;\n                    return;\n                }\n            }\n        }\n        this._objects.push(object);\n    };\n    /**\n     * Returns an array of all objects.\n     */\n    BMSObjects.prototype.all = function () {\n        return this._objects.slice();\n    };\n    /**\n     * Returns a sorted array of all objects.\n     */\n    BMSObjects.prototype.allSorted = function () {\n        var list = this.all();\n        list.sort(function (a, b) {\n            return a.measure + a.fraction - (b.measure + b.fraction);\n        });\n        return list;\n    };\n    return BMSObjects;\n}());\nexports.BMSObjects = BMSObjects;\n/**\n * @typedef {Object} BMSObject An object inside a {BMSChart}.\n * @property {string} channel the raw two-character BMS channel of this object\n * @property {number} measure the measure number, starting at 0 (corresponds to `#000`)\n * @property {number} fraction the fractional position inside the measure,\n *  ranging from 0 (inclusive) to 1 (exclusive).\n *  0 means that the object is at the start of the measure,\n *  whereas 1 means that the object is at the end of the measure.\n * @property {string} value the raw value of the BMS object.\n */\n//# sourceMappingURL=objects.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * A BMSHeader holds the header information in a BMS file, such as\n * `#TITLE`, `#ARTIST`, or `#BPM`.\n *\n * You get retrieve a header using the `get()` method:\n *\n * ```js\n * chart.headers.get('title')\n * ```\n *\n * For some header fields that may contain multiple values, such as `#SUBTITLE`,\n * you can get them all using `getAll()`:\n *\n * ```js\n * chart.headers.getAll()\n * ```\n */\nvar BMSHeaders = /** @class */ (function () {\n    function BMSHeaders() {\n        this._data = {};\n        this._dataAll = {};\n    }\n    /**\n     * Iterates through each header field using a callback function.\n     * @param {(key: string, value: string) => any} callback will be called for each header field\n     */\n    BMSHeaders.prototype.each = function (callback) {\n        for (var i in this._data) {\n            callback(i, this._data[i]);\n        }\n    };\n    /**\n     * Retrieves the header field’s latest value.\n     * @param {string} name field’s name\n     * @return {string | undefined} the field’s latest value\n     */\n    BMSHeaders.prototype.get = function (name) {\n        return this._data[name.toLowerCase()];\n    };\n    /**\n     * Retrieves the header field’s values.\n     * This is useful when a header field is specified multiple times.\n     * @param {string} name field’s name\n     * @return {string[] | undefined}\n     */\n    BMSHeaders.prototype.getAll = function (name) {\n        return this._dataAll[name.toLowerCase()];\n    };\n    /**\n     * Sets the header field’s value.\n     * @param {string} name field’s name\n     * @param {string} value field’s value\n     */\n    BMSHeaders.prototype.set = function (name, value) {\n        var key = name.toLowerCase();\n        this._data[key] = value;\n        (this._dataAll[key] || (this._dataAll[key] = [])).push(value);\n    };\n    return BMSHeaders;\n}());\nexports.BMSHeaders = BMSHeaders;\n//# sourceMappingURL=headers.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction match(text) {\n    var matched = false;\n    return {\n        when: function (pattern, callback) {\n            if (matched)\n                return this;\n            var match = text.match(pattern);\n            if (match) {\n                matched = true;\n                callback(match);\n            }\n            return this;\n        },\n        else: function (callback) {\n            if (matched)\n                return this;\n            callback();\n        }\n    };\n}\nexports.match = match;\n//# sourceMappingURL=match.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar speedcore_1 = require(\"../speedcore\");\nvar chart_1 = require(\"../bms/chart\");\n/**\n * Public: A Spacing represents the relation between song beats and\n * notes spacing.\n *\n * In some rhythm games, such as Pump It Up!,\n * the speed (note spacing factor) may be adjusted by the notechart.\n * StepMania’s `#SPEED` segments is an example.\n */\nvar Spacing = /** @class */ (function () {\n    /**\n     * Constructs a Spacing from the given `segments`.\n     * @param {SpacingSegment[]} segments\n     */\n    function Spacing(segments) {\n        if (segments.length > 0) {\n            this._speedcore = new speedcore_1.Speedcore(segments);\n        }\n    }\n    /**\n     * Returns the note spacing factor at the specified beat.\n     * @param {*} beat the beat\n     */\n    Spacing.prototype.factor = function (beat) {\n        if (this._speedcore) {\n            return this._speedcore.x(beat);\n        }\n        else {\n            return 1;\n        }\n    };\n    /**\n     * Creates a {Spacing} object from the {BMSChart}.\n     *\n     * ## `#SPEED` and `#xxxSP`\n     *\n     * Speed is defined as keyframes. These keyframes will be linearly interpolated.\n     *\n     * ```\n     * #SPEED01 1.0\n     * #SPEED02 2.0\n     *\n     * #001SP:01010202\n     * ```\n     *\n     * In this example, the note spacing factor will gradually change\n     * from 1.0x at beat 1 to 2.0x at beat 2.\n     *\n     * Returns a {Spacing} object\n     *\n     * @param {BMSChart} chart the chart\n     */\n    Spacing.fromBMSChart = function (chart) {\n        void chart_1.BMSChart;\n        var segments = [];\n        chart.objects.allSorted().forEach(function (object) {\n            if (object.channel === 'SP') {\n                var beat = chart.measureToBeat(object.measure, object.fraction);\n                var factor = +chart.headers.get('speed' + object.value);\n                if (isNaN(factor))\n                    return;\n                if (segments.length > 0) {\n                    var previous = segments[segments.length - 1];\n                    previous.dx = (factor - previous.x) / (beat - previous.t);\n                }\n                segments.push({\n                    t: beat,\n                    x: factor,\n                    dx: 0,\n                    inclusive: true\n                });\n            }\n        });\n        if (segments.length > 0) {\n            segments.unshift({\n                t: 0,\n                x: segments[0].x,\n                dx: 0,\n                inclusive: true\n            });\n        }\n        return new Spacing(segments);\n    };\n    return Spacing;\n}());\nexports.Spacing = Spacing;\n/**\n * @typedef {Object} SpacingSegment\n * @property {number} t the beat number\n * @property {number} x the spacing at beat `t`\n * @property {number} dx the amount spacing factor change per beat,\n *  in order to create a continuous speed change\n * @property {boolean} inclusive whether or not to include the\n *  starting beat `t` as part of the segment\n */\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar speedcore_1 = require(\"../speedcore\");\nvar chart_1 = require(\"../bms/chart\");\n/**\n * A Positioning represents the relation between song beats and\n * display position, and provides a way to convert between them.\n *\n * In some rhythm games, the amount of scrolling per beat may be different.\n * StepMania’s `#SCROLL` segments is an example.\n */\nvar Positioning = /** @class */ (function () {\n    /**\n     * Constructs a Positioning from the given `segments`.\n     * @param {PositioningSegment[]} segments\n     */\n    function Positioning(segments) {\n        this._speedcore = new speedcore_1.Speedcore(segments);\n    }\n    /**\n     * Returns the scrolling speed at specified beat.\n     * @param {number} beat the beat number\n     */\n    Positioning.prototype.speed = function (beat) {\n        return this._speedcore.dx(beat);\n    };\n    /**\n     * Returns the total elapsed scrolling amount at specified beat.\n     * @param {number} beat the beat number\n     */\n    Positioning.prototype.position = function (beat) {\n        return this._speedcore.x(beat);\n    };\n    /**\n     * Creates a {Positioning} object from the {BMSChart}.\n     * @param {BMSChart} chart A {BMSChart} to construct a {Positioning} from\n     */\n    Positioning.fromBMSChart = function (chart) {\n        void chart_1.BMSChart;\n        var segments = [];\n        var x = 0;\n        segments.push({\n            t: 0,\n            x: x,\n            dx: 1,\n            inclusive: true\n        });\n        chart.objects.allSorted().forEach(function (object) {\n            if (object.channel === 'SC') {\n                var beat = chart.measureToBeat(object.measure, object.fraction);\n                var dx = +chart.headers.get('scroll' + object.value);\n                if (isNaN(dx))\n                    return;\n                var previous = segments[segments.length - 1];\n                x += (beat - previous.t) * previous.dx;\n                if (beat === 0 && segments.length === 1) {\n                    segments[0].dx = dx;\n                }\n                else {\n                    segments.push({\n                        t: beat,\n                        x: x,\n                        dx: dx,\n                        inclusive: true\n                    });\n                }\n            }\n        });\n        return new Positioning(segments);\n    };\n    return Positioning;\n}());\nexports.Positioning = Positioning;\n/**\n * @typedef PositioningSegment\n * @property {number} t the beat number\n * @property {number} x the total elapsed amount of scrolling at beat `t`\n * @property {number} dx the amount of scrolling per beat\n * @property {boolean} inclusive whether or not to include the\n *  starting beat `t` as part of the segment\n */\n//# sourceMappingURL=index.js.map","\"use strict\";\n// Public: A module that exposes {Keysounds}\n/* module */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar lodash_1 = require(\"../util/lodash\");\nvar chart_1 = require(\"../bms/chart\");\n/**\n * A simple mapping between keysounds ID and the file name.\n * ## Example\n *\n * If you have a BMS like this:\n *\n * ```\n * #WAVAA cat.wav\n * ```\n *\n * Having parsed it using a {Compiler} into a {BMSChart},\n * you can create a {Keysounds} using `fromBMSChart()`:\n *\n * ```js\n * var keysounds = Keysounds.fromBMSChart(bmsChart)\n * ```\n *\n * Then you can retrieve the filename using `.get()`:\n *\n * ```js\n * keysounds.get('aa') // => 'cat.wav'\n * ```\n */\nvar Keysounds = /** @class */ (function () {\n    function Keysounds(map) {\n        /** @type {{[id: string]: string}} */\n        this._map = map;\n    }\n    /**\n     * Returns the keysound file at the specified ID.\n     * @param {string} id the two-character keysound ID\n     * @returns {string | undefined} the sound filename\n     */\n    Keysounds.prototype.get = function (id) {\n        return this._map[id.toLowerCase()];\n    };\n    /**\n     * Returns an array of unique filenames in this Keysounds object.\n     * @returns {string[]} filenames array\n     */\n    Keysounds.prototype.files = function () {\n        return lodash_1.uniq(lodash_1.values(this._map));\n    };\n    /**\n     * Returns a mapping from keysound ID to keysound filename.\n     *\n     * **Warning:** This method returns the internal data structure used\n     * in this Keysounds object. Do not mutate!\n     */\n    Keysounds.prototype.all = function () {\n        return this._map;\n    };\n    /**\n     * Constructs a new {Keysounds} object from a {BMSChart}.\n     * @param {BMSChart} chart\n     */\n    Keysounds.fromBMSChart = function (chart) {\n        void chart_1.BMSChart;\n        var map = {};\n        chart.headers.each(function (name, value) {\n            var match = name.match(/^wav(\\S\\S)$/i);\n            if (!match)\n                return;\n            map[match[1].toLowerCase()] = value;\n        });\n        return new Keysounds(map);\n    };\n    return Keysounds;\n}());\nexports.Keysounds = Keysounds;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar match_1 = require(\"../util/match\");\nvar lodash_1 = require(\"../util/lodash\");\nvar chart_1 = require(\"../bms/chart\");\n/**\n * A SongInfo represents the song info, such as title, artist, genre.\n *\n * ## Example\n *\n * If you have a BMS like this:\n *\n * ```\n * #TITLE Exargon [HYPER]\n * ```\n *\n * Having parsed it using a {Compiler} into a {BMSChart},\n * you can create a {SongInfo} using `fromBMSChart()`:\n *\n * ```js\n * var info = SongInfo.fromBMSChart(bmsChart)\n * ```\n *\n * Then you can query the song information by accessing its properties.\n *\n * ```js\n * info.title     // => 'Exargon'\n * info.subtitles // => ['HYPER']\n * ```\n */\nvar SongInfo = /** @class */ (function () {\n    /**\n     * Constructs a SongInfo with given data\n     * @param {{ [propertyName: string]: any }} info the properties to set on this new instance\n     */\n    function SongInfo(info) {\n        /** the song title */\n        this.title = 'NO TITLE';\n        /** the song artist */\n        this.artist = 'NO ARTIST';\n        /** the song genre */\n        this.genre = 'NO GENRE';\n        /**\n         * the song's subtitles, one line per element.\n         * The subtitle may be used to represent the difficulty name,\n         * such as NORMAL, HYPER, ANOTHER.\n         * @type {string[]}\n         */\n        this.subtitles = [];\n        /**\n         * the song's other artists, one artist per element.\n         * @type {string[]}\n         */\n        this.subartists = [];\n        /**\n         * the difficulty.\n         * Meaning of the number is same as BMS's [`#DIFFICULTY`](http:*hitkey.nekokan.dyndns.info/cmds.htm#DIFFICULTY) header.\n         *\n         * | difficulty | meaning  |\n         * | ----------:|:--------:|\n         * |          1 | BEGINNER |\n         * |          2 | NORMAL   |\n         * |          3 | HYPER    |\n         * |          4 | ANOTHER  |\n         * |          5 | INSANE   |\n         */\n        this.difficulty = 0;\n        /**\n         * the level of the song.\n         * When converted from a BMS chart, this is the value of `#PLAYLEVEL` header.\n         */\n        this.level = 0;\n        if (info)\n            lodash_1.assign(this, info);\n    }\n    /**\n     * Constructs a new {SongInfo} object from a {BMSChart}.\n     * @param {BMSChart} chart A {BMSChart} to construct a {SongInfo} from\n     */\n    SongInfo.fromBMSChart = function (chart) {\n        void chart_1.BMSChart;\n        var info = {};\n        var title = chart.headers.get('title');\n        var artist = chart.headers.get('artist');\n        var genre = chart.headers.get('genre');\n        var difficulty = +chart.headers.get('difficulty');\n        var level = +chart.headers.get('playlevel');\n        var subtitles = chart.headers.getAll('subtitle');\n        var subartists = chart.headers.getAll('subartist');\n        if (typeof title === 'string' && !subtitles) {\n            var extractSubtitle = function (m) {\n                title = m[1];\n                subtitles = [m[2]];\n            };\n            match_1.match(title)\n                .when(/^(.*\\S)\\s*-(.+?)-$/, extractSubtitle)\n                .when(/^(.*\\S)\\s*～(.+?)～$/, extractSubtitle)\n                .when(/^(.*\\S)\\s*\\((.+?)\\)$/, extractSubtitle)\n                .when(/^(.*\\S)\\s*\\[(.+?)\\]$/, extractSubtitle)\n                .when(/^(.*\\S)\\s*<(.+?)>$/, extractSubtitle);\n        }\n        if (title)\n            info.title = title;\n        if (artist)\n            info.artist = artist;\n        if (genre)\n            info.genre = genre;\n        if (subtitles)\n            info.subtitles = subtitles;\n        if (subartists)\n            info.subartists = subartists;\n        if (difficulty)\n            info.difficulty = difficulty;\n        if (level)\n            info.level = level;\n        return new SongInfo(info);\n    };\n    return SongInfo;\n}());\nexports.SongInfo = SongInfo;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar speedcore_1 = require(\"../speedcore\");\nvar lodash_1 = require(\"../util/lodash\");\nvar chart_1 = require(\"../bms/chart\");\nvar precedence = { bpm: 1, stop: 2 };\n/**\n * A Timing represents the timing information of a musical score.\n * A Timing object provides facilities to synchronize between\n * metric time (seconds) and musical time (beats).\n *\n * A Timing are created from a series of actions:\n *\n * - BPM changes.\n * - STOP action.\n */\nvar Timing = /** @class */ (function () {\n    /**\n     * Constructs a Timing with an initial BPM and specified actions.\n     *\n     * Generally, you would use `Timing.fromBMSChart` to create an instance\n     * from a BMSChart, but the constructor may also be used in other situations\n     * unrelated to the BMS file format. (e.g. bmson package)\n     * @param {number} initialBPM\n     * @param {TimingAction[]} actions\n     */\n    function Timing(initialBPM, actions) {\n        var state = { bpm: initialBPM, beat: 0, seconds: 0 };\n        var segments = [];\n        segments.push({\n            t: 0,\n            x: 0,\n            dx: state.bpm / 60,\n            bpm: state.bpm,\n            inclusive: true\n        });\n        actions = actions.slice();\n        actions.sort(function (a, b) {\n            return a.beat - b.beat || precedence[a.type] - precedence[b.type];\n        });\n        actions.forEach(function (action) {\n            var beat = action.beat;\n            var seconds = state.seconds + (beat - state.beat) * 60 / state.bpm;\n            switch (action.type) {\n                case 'bpm':\n                    state.bpm = action.bpm;\n                    segments.push({\n                        t: seconds,\n                        x: beat,\n                        dx: state.bpm / 60,\n                        bpm: state.bpm,\n                        inclusive: true\n                    });\n                    break;\n                case 'stop':\n                    segments.push({\n                        t: seconds,\n                        x: beat,\n                        dx: 0,\n                        bpm: state.bpm,\n                        inclusive: true\n                    });\n                    seconds += (action.stopBeats || 0) * 60 / state.bpm;\n                    segments.push({\n                        t: seconds,\n                        x: beat,\n                        dx: state.bpm / 60,\n                        bpm: state.bpm,\n                        inclusive: false\n                    });\n                    break;\n                default:\n                    throw new Error('Unrecognized segment object!');\n            }\n            state.beat = beat;\n            state.seconds = seconds;\n        });\n        this._speedcore = new speedcore_1.Speedcore(segments);\n        /**\n         * @type {number[]}\n         */\n        this._eventBeats = lodash_1.uniq(lodash_1.map(actions, 'beat'), true);\n    }\n    /**\n     * Convert the given beat into seconds.\n     * @param {number} beat\n     */\n    Timing.prototype.beatToSeconds = function (beat) {\n        return this._speedcore.t(beat);\n    };\n    /**\n     * Convert the given second into beats.\n     * @param {number} seconds\n     */\n    Timing.prototype.secondsToBeat = function (seconds) {\n        return this._speedcore.x(seconds);\n    };\n    /**\n     * Returns the BPM at the specified beat.\n     * @param {number} beat\n     */\n    Timing.prototype.bpmAtBeat = function (beat) {\n        return this._speedcore.segmentAtX(beat).bpm;\n    };\n    /**\n     * Returns an array representing the beats where there are events.\n     */\n    Timing.prototype.getEventBeats = function () {\n        return this._eventBeats;\n    };\n    /**\n     * Creates a Timing instance from a BMSChart.\n     * @param {BMSChart} chart\n     */\n    Timing.fromBMSChart = function (chart) {\n        void chart_1.BMSChart;\n        var actions = [];\n        chart.objects.all().forEach(function (object) {\n            var bpm;\n            var beat = chart.measureToBeat(object.measure, object.fraction);\n            if (object.channel === '03') {\n                bpm = parseInt(object.value, 16);\n                actions.push({ type: 'bpm', beat: beat, bpm: bpm });\n            }\n            else if (object.channel === '08') {\n                bpm = +chart.headers.get('bpm' + object.value);\n                if (!isNaN(bpm))\n                    actions.push({ type: 'bpm', beat: beat, bpm: bpm });\n            }\n            else if (object.channel === '09') {\n                var stopBeats = chart.headers.get('stop' + object.value) / 48;\n                actions.push({ type: 'stop', beat: beat, stopBeats: stopBeats });\n            }\n        });\n        return new Timing(+chart.headers.get('bpm') || 60, actions);\n    };\n    return Timing;\n}());\nexports.Timing = Timing;\n/**\n * @typedef {Object} TimingAction represent timing change\n * @property {'bpm' | 'stop'} type `bpm` for BPM change, and `stop` for stop\n * @property {number} beat where this action occurs\n * @property {number} [bpm] BPM to change to (only for `bpm` type)\n * @property {number} [stopBeats] number of beats to stop (only for `stop` type)\n */\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.IIDX_P1 = {\n    '11': '1',\n    '12': '2',\n    '13': '3',\n    '14': '4',\n    '15': '5',\n    '18': '6',\n    '19': '7',\n    '16': 'SC'\n};\n//# sourceMappingURL=channels.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar data_structure_1 = __importDefault(require(\"data-structure\"));\nexports.Note = new data_structure_1.default({\n    beat: 'number',\n    endBeat: data_structure_1.default.maybe('number'),\n    column: data_structure_1.default.maybe('string'),\n    keysound: 'string'\n});\n//# sourceMappingURL=note.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar note_1 = require(\"./note\");\nvar invariant_1 = __importDefault(require(\"invariant\"));\nvar ChannelMapping = __importStar(require(\"./channels\"));\nvar chart_1 = require(\"../bms/chart\");\n/**\n * A Notes holds the {Note} objects in the game.\n * A note object may or may not be playable.\n *\n * ## Example\n *\n * If you have a BMS like this:\n *\n * ```\n * #00111:AA\n * ```\n *\n * Having parsed it using a {Compiler} into a {BMSChart},\n * you can create a {Notes} using `fromBMSChart()`:\n *\n * ```js\n * var notes = Notes.fromBMSChart(bmsChart)\n * ```\n *\n * Then you can get all notes using `.all()` method\n *\n * ```js\n * notes.all()\n * ```\n */\nvar Notes = /** @class */ (function () {\n    /**\n     * @param {BMSNote[]} notes An array of Note objects\n     */\n    function Notes(notes) {\n        notes.forEach(note_1.Note);\n        this._notes = notes;\n    }\n    /**\n     * Returns the number of notes in this object,\n     * counting both playable and non-playable notes.\n     */\n    Notes.prototype.count = function () {\n        return this._notes.length;\n    };\n    /**\n     * Returns an Array of all notes.\n     */\n    Notes.prototype.all = function () {\n        return this._notes.slice();\n    };\n    /**\n     * Creates a Notes object from a BMSChart.\n     * @param {BMSChart} chart the chart to process\n     * @param {BMSChartOptions} options options\n     */\n    Notes.fromBMSChart = function (chart, options) {\n        void chart_1.BMSChart;\n        options = options || {};\n        var mapping = options.mapping || Notes.CHANNEL_MAPPING.IIDX_P1;\n        var builder = new BMSNoteBuilder(chart, { mapping: mapping });\n        return builder.build();\n    };\n    return Notes;\n}());\nexports.Notes = Notes;\nNotes.CHANNEL_MAPPING = ChannelMapping;\nvar BMSNoteBuilder = /** @class */ (function () {\n    function BMSNoteBuilder(chart, options) {\n        this._chart = chart;\n        invariant_1.default(options.mapping, 'Expected options.mapping');\n        invariant_1.default(typeof options.mapping === 'object', 'options.mapping must be object');\n        this._mapping = options.mapping;\n    }\n    BMSNoteBuilder.prototype.build = function () {\n        this._notes = [];\n        this._activeLN = {};\n        this._lastNote = {};\n        this._lnObj = (this._chart.headers.get('lnobj') || '').toLowerCase();\n        this._channelMapping = this._mapping;\n        this._objects = this._chart.objects.allSorted();\n        this._objects.forEach(function (object) {\n            this._handle(object);\n        }.bind(this));\n        return new Notes(this._notes);\n    };\n    BMSNoteBuilder.prototype._handle = function (object) {\n        if (object.channel === '01') {\n            this._handleNormalNote(object);\n        }\n        else {\n            switch (object.channel.charAt(0)) {\n                case '1':\n                case '2':\n                    this._handleNormalNote(object);\n                    break;\n                case '5':\n                case '6':\n                    this._handleLongNote(object);\n                    break;\n            }\n        }\n    };\n    BMSNoteBuilder.prototype._handleNormalNote = function (object) {\n        var channel = this._normalizeChannel(object.channel);\n        var beat = this._getBeat(object);\n        if (object.value.toLowerCase() === this._lnObj) {\n            if (this._lastNote[channel]) {\n                this._lastNote[channel].endBeat = beat;\n            }\n        }\n        else {\n            var note = {\n                beat: beat,\n                endBeat: undefined,\n                keysound: object.value,\n                column: this._getColumn(channel)\n            };\n            this._lastNote[channel] = note;\n            this._notes.push(note);\n        }\n    };\n    BMSNoteBuilder.prototype._handleLongNote = function (object) {\n        var channel = this._normalizeChannel(object.channel);\n        var beat = this._getBeat(object);\n        if (this._activeLN[channel]) {\n            var note = this._activeLN[channel];\n            note.endBeat = beat;\n            this._notes.push(note);\n            delete this._activeLN[channel];\n        }\n        else {\n            this._activeLN[channel] = {\n                beat: beat,\n                keysound: object.value,\n                column: this._getColumn(channel)\n            };\n        }\n    };\n    BMSNoteBuilder.prototype._getBeat = function (object) {\n        return this._chart.measureToBeat(object.measure, object.fraction);\n    };\n    BMSNoteBuilder.prototype._getColumn = function (channel) {\n        return this._channelMapping[channel];\n    };\n    BMSNoteBuilder.prototype._normalizeChannel = function (channel) {\n        return channel.replace(/^5/, '1').replace(/^6/, '2');\n    };\n    return BMSNoteBuilder;\n}());\n/**\n * @typedef {Object} BMSNote A single note in a notechart.\n * @property {number} beat\n * @property {number} [endBeat]\n * @property {string} [column]\n * @property {string} keysound\n */\n/**\n * @typedef {Object} BMSChartOptions\n * @property {{[channel: string]: string}} [mapping]\n *  the mapping from BMS channel to game channel.\n *  Default value is the IIDX_P1 mapping.\n */\n//# sourceMappingURL=index.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar data_structure_1 = __importDefault(require(\"data-structure\"));\nexports.Segment = new data_structure_1.default({\n    t: 'number',\n    x: 'number',\n    dx: 'number'\n});\n//# sourceMappingURL=segment.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// Public: A module that takes a string representing the BMS notechart,\n// parses it, and compiles into a {BMSChart}.\n/* module */\nvar match_1 = require(\"../util/match\");\nvar chart_1 = require(\"../bms/chart\");\nvar matchers = {\n    bms: {\n        random: /^#RANDOM\\s+(\\d+)$/i,\n        if: /^#IF\\s+(\\d+)$/i,\n        endif: /^#ENDIF$/i,\n        timeSignature: /^#(\\d\\d\\d)02:(\\S*)$/,\n        channel: /^#(?:EXT\\s+#)?(\\d\\d\\d)(\\S\\S):(\\S*)$/,\n        header: /^#(\\w+)(?:\\s+(\\S.*))?$/\n    },\n    dtx: {\n        random: /^#RANDOM\\s+(\\d+)$/i,\n        if: /^#IF\\s+(\\d+)$/i,\n        endif: /^#ENDIF$/i,\n        timeSignature: /^#(\\d\\d\\d)02:\\s*(\\S*)$/,\n        channel: /^#(?:EXT\\s+#)?(\\d\\d\\d)(\\S\\S):\\s*(\\S*)$/,\n        header: /^#(\\w+):(?:\\s+(\\S.*))?$/\n    }\n};\n/**\n * Reads the string representing the BMS notechart, parses it,\n * and compiles into a {BMSChart}.\n * @param {string} text the BMS notechart\n * @param {BMSCompileOptions} options additional parser options\n */\nfunction compile(text, options) {\n    options = options || {};\n    var chart = new chart_1.BMSChart();\n    var rng = options.rng ||\n        function (max) {\n            return 1 + Math.floor(Math.random() * max);\n        };\n    var matcher = matchers[options.format] || matchers.bms;\n    var randomStack = [];\n    var skipStack = [false];\n    var result = {\n        headerSentences: 0,\n        channelSentences: 0,\n        controlSentences: 0,\n        skippedSentences: 0,\n        malformedSentences: 0,\n        /**\n         * The resulting chart\n         */\n        chart: chart,\n        /**\n         * Warnings found during compilation\n         * @type {{lineNumber: number, message: string}[]}\n         */\n        warnings: []\n    };\n    eachLine(text, function (text, lineNumber) {\n        var flow = true;\n        if (text.charAt(0) !== '#')\n            return;\n        match_1.match(text)\n            .when(matcher.random, function (m) {\n            result.controlSentences += 1;\n            randomStack.push(rng(+m[1]));\n        })\n            .when(matcher.if, function (m) {\n            result.controlSentences += 1;\n            skipStack.push(randomStack[randomStack.length - 1] !== +m[1]);\n        })\n            .when(matcher.endif, function (m) {\n            result.controlSentences += 1;\n            skipStack.pop();\n        })\n            .else(function () {\n            flow = false;\n        });\n        if (flow)\n            return;\n        var skipped = skipStack[skipStack.length - 1];\n        match_1.match(text)\n            .when(matcher.timeSignature, function (m) {\n            result.channelSentences += 1;\n            if (!skipped)\n                chart.timeSignatures.set(+m[1], +m[2]);\n        })\n            .when(matcher.channel, function (m) {\n            result.channelSentences += 1;\n            if (!skipped)\n                handleChannelSentence(+m[1], m[2], m[3], lineNumber);\n        })\n            .when(matcher.header, function (m) {\n            result.headerSentences += 1;\n            if (!skipped)\n                chart.headers.set(m[1], m[2]);\n        })\n            .else(function () {\n            warn(lineNumber, 'Invalid command');\n        });\n    });\n    return result;\n    function handleChannelSentence(measure, channel, string, lineNumber) {\n        var items = Math.floor(string.length / 2);\n        if (items === 0)\n            return;\n        for (var i = 0; i < items; i++) {\n            var value = string.substr(i * 2, 2);\n            var fraction = i / items;\n            if (value === '00')\n                continue;\n            chart.objects.add({\n                measure: measure,\n                fraction: fraction,\n                value: value,\n                channel: channel,\n                lineNumber: lineNumber\n            });\n        }\n    }\n    function warn(lineNumber, message) {\n        result.warnings.push({\n            lineNumber: lineNumber,\n            message: message\n        });\n    }\n}\nexports.compile = compile;\nfunction eachLine(text, callback) {\n    text\n        .split(/\\r\\n|\\r|\\n/)\n        .map(function (line) {\n        return line.trim();\n    })\n        .forEach(function (line, index) {\n        callback(line, index + 1);\n    });\n}\n/**\n * @typedef {Object} BMSCompileOptions\n * @property {'bms' | 'dtx'} [format='bms'] File format\n * @property {(max: number): number} [rng] A function that generates a random number.\n *  It is used when processing `#RANDOM n` directive.\n *  This function should return an integer number between 1 and `n`.\n */\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Given the filename, returns the reader options.\n * @param {string} filename\n */\nfunction getReaderOptionsFromFilename(filename) {\n    var forceEncoding;\n    if (filename.match(/\\.sjis\\.\\w+$/i)) {\n        forceEncoding = 'Shift-JIS';\n    }\n    if (filename.match(/\\.euc_kr\\.\\w+$/i)) {\n        forceEncoding = 'EUC-KR';\n    }\n    if (filename.match(/\\.utf8\\.\\w+$/i)) {\n        forceEncoding = 'UTF-8';\n    }\n    return { forceEncoding: forceEncoding };\n}\nexports.getReaderOptionsFromFilename = getReaderOptionsFromFilename;\n//# sourceMappingURL=getReaderOptionsFromFilename.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/* global FileReader, Blob */\nvar chardet = require('bemuse-chardet/bemuse-chardet');\nfunction read(buffer) {\n    throw new Error('Synchronous read unsupported in browser!');\n}\nexports.read = read;\nfunction readAsync(buffer, options, callback) {\n    if (!callback) {\n        callback = options;\n        options = null;\n    }\n    var charset = (options && options.forceEncoding) || chardet.detect(buffer);\n    var reader = new FileReader();\n    reader.onload = function () {\n        callback(null, reader.result);\n    };\n    reader.onerror = function () {\n        callback(new Error('cannot read it'));\n    };\n    reader.readAsText(new Blob([buffer]), charset);\n}\nexports.readAsync = readAsync;\nvar getReaderOptionsFromFilename_1 = require(\"./getReaderOptionsFromFilename\");\nexports.getReaderOptionsFromFilename = getReaderOptionsFromFilename_1.getReaderOptionsFromFilename;\n//# sourceMappingURL=index.web.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar headers_1 = require(\"./headers\");\nvar objects_1 = require(\"./objects\");\nvar time_signatures_1 = require(\"../time-signatures\");\n/**\n * A BMSChart holds information about a particular BMS notechart.\n * Note that a BMSChart does not contain any information about `#RANDOM`,\n * as they are already processed after compilation.\n *\n * There is not many useful things you can do with a BMSChart other than\n * accessing the header fields and objects inside it.\n *\n * To extract information from a BMSChart,\n * please look at the documentation of higher-level classes,\n * such as {Keysounds}, {Notes}, and {Timing}.\n */\nvar BMSChart = /** @class */ (function () {\n    function BMSChart() {\n        /**\n         * {BMSHeaders} representing the BMS-specific headers of this notechart\n         */\n        this.headers = new headers_1.BMSHeaders();\n        /**\n         * {BMSObjects} representing all objects of this notechart\n         */\n        this.objects = new objects_1.BMSObjects();\n        /**\n         * {TimeSignatures} representing the time signature information in this chart\n         */\n        this.timeSignatures = new time_signatures_1.TimeSignatures();\n    }\n    /**\n     * Public: Converts measure number and fraction into beat.\n     * A single beat is equivalent to a quarter note in common time signature.\n     *\n     * @param {number} measure representing the measure number, starting from 0\n     * @param {number} fraction representing the fraction inside that measure, from 0 to 1\n     */\n    BMSChart.prototype.measureToBeat = function (measure, fraction) {\n        return this.timeSignatures.measureToBeat(measure, fraction);\n    };\n    return BMSChart;\n}());\nexports.BMSChart = BMSChart;\n//# sourceMappingURL=chart.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar segment_1 = require(\"./segment\");\n/**\n *\n * Speedcore is a small internally-used library.\n * A Speedcore represents a single dimensional keyframed linear motion\n * (as in equation x = f(t)), and is useful when working\n * with BPM changes ({Timing}), note spacing factor ({Spacing}), or scrolling\n * segments ({Positioning}).\n * A Speedcore is constructed from an array of Segments.\n *\n * A {Segment} is defined as `{ t, x, dx }`, such that:\n *\n * * speedcore.x(segment.t) = segment.x\n * * speedcore.t(segment.x) = segment.t\n * * speedcore.x(segment.t + dt) = segment.x + (segment.dx / dt)\n *\n *\n * ## Explanation\n *\n * One way to think of these segments is to think about tempo changes, where:\n *\n * * `t` is the elapsed time (in seconds) since song start.\n * * `x` is the elapsed beat since song start.\n * * `dx` is the amount of `x` increase per `t`. In this case, it has the\n *   unit of beats per second.\n *\n * For example, consider a song that starts at 140 BPM.\n * 32 beats later, the tempo changes to 160 BPM.\n * 128 beats later (at beat 160), the tempo reverts to 140 BPM.\n *\n * We can derive three segments:\n *\n * 1. At time 0, we are at beat 0, and moving at 2.333 beats per second.\n * 2. At 13.714s, we are at beat 32, moving at 2.667 beats per second.\n * 3. At 61.714s, we are at beat 160, moving at 2.333 beats per second.\n *\n * This maps out to this data structure:\n *\n * ```js\n * [ [0]: { t:  0.000,  x:   0,  dx: 2.333,  inclusive: true },\n *   [1]: { t: 13.714,  x:  32,  dx: 2.667,  inclusive: true },\n *   [2]: { t: 61.714,  x: 160,  dx: 2.333,  inclusive: true } ]\n * ```\n *\n * With this data, it is possible to find out the value of `x` at any given `t`.\n *\n * For example, to answer the question, “what is the beat number at 30s?”\n * First, we find the segment with maximum value of `t < 30`, and we get\n * the segment `[1]`.\n *\n * We calculate `segment.x + (t - segment.t) * segment.dx`.\n * The result beat number is (32 + (30 - 13.714) * 2.667) = 75.435.\n *\n * We can also perform the reverse calculation in a similar way, by reversing\n * the equation.\n *\n * Interestingly, we can use these segments to represent the effect of\n * both BPM changes and STOP segments in the same array.\n * For example, a 150-BPM song with a 2-beat stop in the 32nd beat\n * can be represented like this:\n *\n * ```js\n * [ [0]: { t:  0.0,  x:  0,  dx: 2.5,  inclusive: true  },\n *   [1]: { t: 12.8,  x: 32,  dx: 0,    inclusive: true  },\n *   [2]: { t: 13.6,  x: 32,  dx: 2.5,  inclusive: false } ]\n * ```\n */\nvar Speedcore = /** @class */ (function () {\n    /**\n     * Constructs a new `Speedcore` from given segments.\n     * @param {SpeedSegment[]} segments\n     */\n    function Speedcore(segments) {\n        this._segments = segments.map(segment_1.Segment);\n    }\n    Speedcore.prototype._reached = function (index, typeFn, position) {\n        if (index >= this._segments.length)\n            return false;\n        var segment = this._segments[index];\n        var target = typeFn(segment);\n        return segment.inclusive ? position >= target : position > target;\n    };\n    Speedcore.prototype._segmentAt = function (typeFn, position) {\n        for (var i = 0; i < this._segments.length; i++) {\n            if (!this._reached(i + 1, typeFn, position))\n                return this._segments[i];\n        }\n    };\n    Speedcore.prototype.segmentAtX = function (x) {\n        return this._segmentAt(X, x);\n    };\n    Speedcore.prototype.segmentAtT = function (t) {\n        return this._segmentAt(T, t);\n    };\n    /**\n     * Calculates the _t_, given _x_.\n     * @param {number} x\n     */\n    Speedcore.prototype.t = function (x) {\n        var segment = this.segmentAtX(x);\n        return segment.t + (x - segment.x) / (segment.dx || 1);\n    };\n    /**\n     * Calculates the _x_, given _t_.\n     * @param {number} t\n     */\n    Speedcore.prototype.x = function (t) {\n        var segment = this.segmentAtT(t);\n        return segment.x + (t - segment.t) * segment.dx;\n    };\n    /**\n     * Finds the _dx_, given _t_.\n     * @param {number} t\n     */\n    Speedcore.prototype.dx = function (t) {\n        var segment = this.segmentAtT(t);\n        return segment.dx;\n    };\n    return Speedcore;\n}());\nexports.Speedcore = Speedcore;\nvar T = function (segment) {\n    return segment.t;\n};\nvar X = function (segment) {\n    return segment.x;\n};\n/**\n * @typedef {Object} SpeedSegment\n * @property {number} t\n * @property {number} x\n * @property {number} dx the amount of change in x per t\n * @property {boolean} inclusive whether or not the segment includes the t\n */\n//# sourceMappingURL=index.js.map","import bytes from 'bytes'\n\nlet wrap = f => progress => (progress.progress !== null ? f(progress) : '')\n\n// Formats the `Progress` as bytes (e.g. 1.23mb of 1.31mb).\nexport let BYTES_FORMATTER = wrap(\n  progress => bytes(progress.current) + ' / ' + bytes(progress.total)\n)\n\n// Formats the `Progress` as percentage.\nexport let PERCENTAGE_FORMATTER = wrap(\n  progress => (progress.current / progress.total * 100).toFixed(1) + '%'\n)\n\n// Formats the `Progress` simply by using the value of `Progress#extra`.\nexport let EXTRA_FORMATTER = wrap(progress => progress.extra + '')\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// A subset of lodash that we actually use.\nvar lodash_uniq_1 = __importDefault(require(\"lodash.uniq\"));\nexports.uniq = lodash_uniq_1.default;\nvar lodash_map_1 = __importDefault(require(\"lodash.map\"));\nexports.map = lodash_map_1.default;\nvar lodash_values_1 = __importDefault(require(\"lodash.values\"));\nexports.values = lodash_values_1.default;\nvar lodash_assign_1 = __importDefault(require(\"lodash.assign\"));\nexports.assign = lodash_assign_1.default;\n//# sourceMappingURL=lodash.js.map"],"sourceRoot":""}