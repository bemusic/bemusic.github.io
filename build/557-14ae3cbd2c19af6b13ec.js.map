{"version":3,"file":"build/557-14ae3cbd2c19af6b13ec.js","mappings":"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","sources":["file:///home/runner/work/bemuse/bemuse/bemuse/src/app/interactors/getLR2Score.js","file:///home/runner/work/bemuse/bemuse/bemuse/src/custom-folder/index.ts","file:///home/runner/work/bemuse/bemuse/bemuse/src/custom-song-loader/index.ts","file:///home/runner/work/bemuse/bemuse/bemuse/src/online/data-store.ts","file:///home/runner/work/bemuse/bemuse/bemuse/src/online/id.js","file:///home/runner/work/bemuse/bemuse/bemuse/src/rules/mapping-mode.ts","file:///home/runner/work/bemuse/bemuse/bemuse/src/online/level.ts","file:///home/runner/work/bemuse/bemuse/bemuse/src/online/index.ts","file:///home/runner/work/bemuse/bemuse/bemuse/src/online/operations.ts","file:///home/runner/work/bemuse/bemuse/bemuse/src/online/scoreboard-system/createFakeScoreboardClient.ts","file:///home/runner/work/bemuse/bemuse/bemuse/src/online/scoreboard-system/createNextScoreboardClient.ts","file:///home/runner/work/bemuse/bemuse/bemuse/src/online/scoreboard-system/OnlineService.ts"],"sourcesContent":["// Calculates the score as if it was computed by LR2.\n//\n// - `deltas` The array representing the player’s delta offsets in **seconds**.\n// - `timegates` A 2-tuple containing **millisecond values**:\n//     - `[0]` The timegate for PGREAT judgment.\n//     - `[1]` The timegate for GREAT judgment.\n//\n// This module is implemented so that we can compare the difficulty\n// of grading system in Bemuse to Lunatic Rave 2’s.\n//\nexport function getLR2Score(deltas, [meticulousWindow, preciseWindow]) {\n  let sum = 0\n  for (const delta of deltas) {\n    const difference = Math.abs(delta) * 1000\n    if (difference < meticulousWindow) sum += 1\n    if (difference < preciseWindow) sum += 1\n  }\n  return sum\n}\n\nexport default getLR2Score\n","import _ from 'lodash'\nimport { get, set, del } from 'idb-keyval'\nimport pMemoize from 'p-memoize'\nimport {\n  CustomFolderChartFile,\n  CustomFolderFolderEntry,\n  CustomFolderSong,\n  CustomFolderState,\n} from './types'\nimport { loadSongFromResources } from 'bemuse/custom-song-loader'\nimport { ICustomSongResources, IResources } from 'bemuse/resources/types'\nimport { FileResource } from 'bemuse/resources/custom-song-resources'\nimport { Song } from 'bemuse/collection-model/types'\n\nexport interface CustomFolderContext {\n  get: (key: string) => Promise<CustomFolderState | undefined>\n  set: (key: string, value: CustomFolderState) => Promise<void>\n  del: (key: string) => Promise<void>\n}\n\nexport class CustomFolderContextImpl implements CustomFolderContext {\n  get = get\n  set = set\n  del = del\n}\n\nconst CUSTOM_FOLDER_KEYVAL_KEY = 'custom-folder-1'\n\nexport async function setCustomFolder(\n  context: CustomFolderContext,\n  folder: FileSystemDirectoryHandle\n) {\n  await context.set(CUSTOM_FOLDER_KEYVAL_KEY, {\n    handle: folder,\n  })\n}\n\nexport async function clearCustomFolder(context: CustomFolderContext) {\n  await context.del(CUSTOM_FOLDER_KEYVAL_KEY)\n}\n\nexport async function getCustomFolderState(context: CustomFolderContext) {\n  return context.get(CUSTOM_FOLDER_KEYVAL_KEY)\n}\n\nexport const getDefaultCustomFolderContext = _.once(\n  () => new CustomFolderContextImpl()\n)\n\nexport type CustomFolderScanIO = {\n  log: (message: string) => void\n  setStatus: (message: string) => void\n  updateState: (state: CustomFolderState) => void\n}\n\nexport async function scanFolder(\n  context: CustomFolderContext,\n  io: CustomFolderScanIO\n) {\n  let state = await getCustomFolderState(context)\n  const { log, setStatus, updateState } = io\n  for (let i = 1; ; i++) {\n    log(`Iteration #${i} start`)\n    const result = await scanIteration(state, io)\n\n    // If there is nothing to be done in the very first iteration, let’s rescan the folder for new chart files.\n    if (!result && i === 1) {\n      state = { ...state, chartFilesScanned: false }\n      continue\n    }\n\n    if (!result) {\n      break\n    }\n    if (result.nextState) {\n      state = result.nextState\n      updateState(state)\n      setStatus(`Saving state (iteration #${i})`)\n      await context.set(CUSTOM_FOLDER_KEYVAL_KEY, state)\n    }\n    if (!result.moreIterationsNeeded) {\n      break\n    }\n  }\n  setStatus('Done scanning.')\n}\n\nasync function scanIteration(\n  inputState: CustomFolderState | undefined,\n  io: CustomFolderScanIO\n): Promise<ScanIterationResult | undefined> {\n  const result = await checkFolderStateAndPermissions(inputState, io)\n  if (!result) {\n    return\n  }\n  const { state, handle } = result\n\n  if (!state.chartFilesScanned) {\n    return scanAllChartFiles(state, handle, io)\n  }\n\n  if ((state?.foldersToUpdate?.length ?? 0) > 0) {\n    return updateFolders(state, handle, io)\n  }\n\n  if ((state?.foldersToRemove?.length ?? 0) > 0) {\n    return removeFolders(state, handle, io)\n  }\n}\n\nasync function checkFolderStateAndPermissions(\n  state: CustomFolderState | undefined,\n  io: CustomFolderScanIO\n): Promise<\n  | {\n      state: CustomFolderState\n      handle: FileSystemDirectoryHandle\n    }\n  | undefined\n> {\n  const { log, setStatus } = io\n  if (!state) {\n    const message = 'No custom folder set.'\n    log(message)\n    setStatus(message)\n    return\n  }\n\n  const { handle } = state\n  if (!handle) {\n    const message = 'No folder selected.'\n    log(message)\n    setStatus(message)\n    return\n  }\n\n  let permission = await handle.queryPermission({ mode: 'read' })\n  if (permission === 'prompt') {\n    setStatus('Waiting for permission — please grant access to the folder.')\n    permission = await handle.requestPermission({ mode: 'read' })\n  }\n  if (permission !== 'granted') {\n    log('Unable to read the folder due to lack of permissions.')\n    setStatus('Unable to read the folder due to lack of permissions.')\n    return\n  }\n\n  return { state, handle }\n}\n\nasync function scanAllChartFiles(\n  state: CustomFolderState,\n  handle: FileSystemDirectoryHandle,\n  io: CustomFolderScanIO\n): Promise<ScanIterationResult | undefined> {\n  const { log, setStatus } = io\n  const chartFileScanner = new ChartFileScanner(state.chartFiles, true)\n  await searchForChartFiles(handle, chartFileScanner, io)\n\n  const newChartFiles = chartFileScanner.getNewChartFiles()\n  const foldersToUpdate = chartFileScanner.getFoldersToUpdate()\n  const foldersToRemove = chartFileScanner.getFoldersToRemove()\n  const message =\n    'Scanning done. ' +\n    [\n      `Charts: ${newChartFiles.length}`,\n      `Folders: ${chartFileScanner.getFolderCount()}`,\n      `Folders to update: ${foldersToUpdate.length}`,\n      `Folders to remove: ${foldersToRemove.length}`,\n    ].join('; ')\n  log(message)\n  setStatus(message)\n\n  return {\n    nextState: {\n      ...state,\n      chartFiles: newChartFiles,\n      chartFilesScanned: true,\n      foldersToUpdate,\n      foldersToRemove,\n    },\n    moreIterationsNeeded: true,\n  }\n}\n\nasync function searchForChartFiles(\n  directoryHandle: FileSystemDirectoryHandle,\n  chartFileScanner: ChartFileScanner,\n  io: CustomFolderScanIO,\n  parentPath: string[] = []\n): Promise<void> {\n  let entriesRead = 0\n  const { log, setStatus } = io\n  for await (const [name, handle] of directoryHandle) {\n    const childPath = [...parentPath, name]\n    try {\n      if (handle.kind === 'directory') {\n        await searchForChartFiles(handle, chartFileScanner, io, childPath)\n      } else if (/\\.(bms|bme|bml|bmson)$/i.test(name)) {\n        const fileHandle = handle\n        await chartFileScanner.addPath(childPath, {\n          getModifiedDate: async () => {\n            const file = await fileHandle.getFile()\n            return file.lastModified\n          },\n        })\n      }\n    } catch (error) {\n      log(`Error while processing ${childPath.join('/')}: ${error}`)\n      console.error(error)\n    }\n    entriesRead++\n    const childPathStr = formatPath(childPath)\n    setStatus(\n      `Scanning for chart files. ${entriesRead} entries read. Just processed: ${childPathStr}`\n    )\n  }\n}\n\nasync function updateFolders(\n  state: CustomFolderState,\n  handle: FileSystemDirectoryHandle,\n  io: CustomFolderScanIO\n): Promise<ScanIterationResult | undefined> {\n  const { log, setStatus } = io\n  if ((state?.foldersToUpdate?.length || 0) > 0) {\n    const foldersToUpdate = [...state.foldersToUpdate!]\n    const n = foldersToUpdate.length\n    const songsToSave: CustomFolderSong[] = []\n    const updatedPathSet = new Set<string>()\n    const deadline = Date.now() + 5000\n\n    for (const [i, folder] of foldersToUpdate.entries()) {\n      updatedPathSet.add(JSON.stringify(folder.path))\n\n      const pathStr = formatPath(folder.path)\n      const remaining = n - i\n      log(`Updating folder “${pathStr}” (${remaining} remaining)`)\n      const statusPrefix = `Folder “${pathStr}” (${remaining} remaining)`\n      setStatus(statusPrefix)\n\n      const resources = await getResourcesForFolder(\n        handle,\n        folder.path,\n        state.chartFiles || []\n      )\n      const { resources: _unused, ...song } = await loadSongFromResources(\n        resources,\n        {\n          onMessage: (text) => {\n            log(text)\n            setStatus(`${statusPrefix} ${text}`)\n          },\n        }\n      )\n      if (song.charts.length > 0) {\n        songsToSave.push({\n          path: folder.path,\n          song,\n        })\n      }\n      if (Date.now() > deadline) {\n        break\n      }\n    }\n\n    const songsToSavePathSet = new Set(\n      songsToSave.map((song) => JSON.stringify(song.path))\n    )\n    const newSongs = [\n      ...(state.songs || []).filter(\n        (song) => !songsToSavePathSet.has(JSON.stringify(song.path))\n      ),\n      ...songsToSave,\n    ]\n    const newFoldersToUpdate = foldersToUpdate.filter(\n      (folder) => !updatedPathSet.has(JSON.stringify(folder.path))\n    )\n    return {\n      nextState: {\n        ...state,\n        foldersToUpdate: newFoldersToUpdate,\n        songs: newSongs,\n      },\n      moreIterationsNeeded: true,\n    }\n  }\n}\n\nasync function removeFolders(\n  state: CustomFolderState,\n  handle: FileSystemDirectoryHandle,\n  io: CustomFolderScanIO\n): Promise<ScanIterationResult | undefined> {\n  const { log, setStatus } = io\n\n  if ((state.foldersToRemove?.length ?? 0) > 0) {\n    let remainingSongs = state.songs || []\n    const foldersToRemove = [...state.foldersToRemove!]\n    const n = foldersToRemove.length\n    const removedPathSet = new Set<string>()\n    const deadline = Date.now() + 5000\n\n    for (const [i, folder] of foldersToRemove.entries()) {\n      removedPathSet.add(JSON.stringify(folder.path))\n\n      const pathStr = formatPath(folder.path)\n      const remaining = n - i\n      log(`Removing folder “${pathStr}” (${remaining} remaining)`)\n      const statusPrefix = `Folder “${pathStr}” (${remaining} remaining)`\n      setStatus(statusPrefix)\n\n      remainingSongs = remainingSongs.filter((song) => {\n        return !song.path.includes(pathStr)\n      })\n\n      if (Date.now() > deadline) break\n    }\n\n    const newFoldersToRemove = foldersToRemove.filter(\n      (folder) => !removedPathSet.has(JSON.stringify(folder.path))\n    )\n    return {\n      nextState: {\n        ...state,\n        foldersToRemove: newFoldersToRemove,\n        songs: remainingSongs,\n      },\n      moreIterationsNeeded: true,\n    }\n  }\n}\n\nasync function getResourcesForFolder(\n  rootFolderHandle: FileSystemDirectoryHandle,\n  path: string[],\n  chartFiles: CustomFolderChartFile[]\n): Promise<ICustomSongResources> {\n  const folderHandle = await getFolderHandleByPath(rootFolderHandle, path)\n  const files = chartFiles.filter(\n    (file) =>\n      file.path.length === path.length + 1 &&\n      path.every((p, i) => p === file.path[i])\n  )\n  return {\n    fileList: Promise.resolve(\n      files.map((file) => file.path[file.path.length - 1])\n    ),\n    async file(name) {\n      const fileHandle = await folderHandle.getFileHandle(name)\n      const file = await fileHandle.getFile()\n      return new FileResource(file)\n    },\n  }\n}\n\nasync function getFolderHandleByPath(\n  rootFolderHandle: FileSystemDirectoryHandle,\n  path: string[]\n): Promise<FileSystemDirectoryHandle> {\n  let handle = rootFolderHandle\n  for (const name of path) {\n    handle = await handle.getDirectoryHandle(name)\n  }\n  return handle\n}\n\ntype ScanIterationResult = {\n  nextState?: CustomFolderState\n  moreIterationsNeeded: boolean\n}\n\nclass ChartFileScanner {\n  private existingMap: Map<string, CustomFolderChartFile>\n  private existingFolderSet: Set<string>\n  private foundFolderSet = new Set<string>()\n  private updatedFolderSet = new Set<string>()\n  private newChartFiles: CustomFolderChartFile[] = []\n  private changedPaths: { path: string[]; lastModified: number }[] = []\n\n  constructor(\n    private previous: CustomFolderState['chartFiles'] = [],\n    private fast = false\n  ) {\n    this.existingMap = new Map(\n      _.map(this.previous, (file) => [JSON.stringify(file.path), file])\n    )\n    this.existingFolderSet = new Set(\n      _.map(this.previous, (file) => JSON.stringify(file.path.slice(0, -1)))\n    )\n  }\n\n  async addPath(\n    childPath: string[],\n    io: {\n      getModifiedDate: () => Promise<number>\n    }\n  ) {\n    const key = JSON.stringify(childPath)\n    const folderKey = JSON.stringify(childPath.slice(0, -1))\n    const existing = this.existingMap.get(key)\n    this.foundFolderSet.add(folderKey)\n    if (existing) {\n      if (!this.fast) {\n        const lastModified = await io.getModifiedDate()\n        if (lastModified > existing.lastModified) {\n          this.changedPaths.push({ path: childPath, lastModified })\n          this.newChartFiles.push({ path: childPath, lastModified })\n          this.updatedFolderSet.add(folderKey)\n        } else {\n          this.newChartFiles.push(existing)\n        }\n      } else {\n        this.newChartFiles.push(existing)\n      }\n    } else {\n      const lastModified = await io.getModifiedDate()\n      this.changedPaths.push({ path: childPath, lastModified })\n      this.newChartFiles.push({ path: childPath, lastModified })\n      this.updatedFolderSet.add(folderKey)\n    }\n  }\n\n  getNewChartFiles() {\n    return this.newChartFiles\n  }\n\n  getFoldersToUpdate(): CustomFolderFolderEntry[] {\n    return [...this.updatedFolderSet].map((folderKey) => ({\n      path: JSON.parse(folderKey) as string[],\n    }))\n  }\n\n  getFoldersToRemove(): CustomFolderFolderEntry[] {\n    return [...this.existingFolderSet]\n      .filter((folderKey) => !this.foundFolderSet.has(folderKey))\n      .map((folderKey) => ({\n        path: JSON.parse(folderKey) as string[],\n      }))\n  }\n\n  getFolderCount() {\n    return this.foundFolderSet.size\n  }\n}\nfunction formatPath(childPath: string[]) {\n  return childPath.join('¥')\n}\n\nexport async function getSongsFromCustomFolders(\n  context: CustomFolderContext\n): Promise<Song[]> {\n  const state = await getCustomFolderState(context)\n  if (!state || !state.handle) {\n    return []\n  }\n\n  const customFolderSongs = state.songs || []\n  const resourceFactory = new CustomFolderResourceFactory(state.handle)\n  const out: Song[] = []\n  for (const [i, customFolderSong] of customFolderSongs.entries()) {\n    try {\n      const resources = resourceFactory.getResources(customFolderSong.path)\n      out.push({\n        ...customFolderSong.song,\n        resources,\n        custom: true,\n        id: `__custom_${i}`,\n      })\n    } catch (e) {\n      console.error(e)\n    }\n  }\n  return out\n}\n\nclass CustomFolderResourceFactory {\n  constructor(private rootFolderHandle: FileSystemDirectoryHandle) {}\n  getGrant = pMemoize(async () => {\n    const handle = this.rootFolderHandle\n    let permission = await handle.queryPermission({ mode: 'read' })\n    if (permission === 'prompt') {\n      permission = await handle.requestPermission({ mode: 'read' })\n    }\n    if (permission !== 'granted') {\n      throw new Error('Permission has not been granted')\n    }\n    return permission\n  })\n\n  getResources(path: string[]): IResources {\n    const getFolderHandle = pMemoize(async () => {\n      await this.getGrant()\n      return getFolderHandleByPath(this.rootFolderHandle, path)\n    })\n    return {\n      async file(name) {\n        const folder = await getFolderHandle()\n        const fileHandle = await folder.getFileHandle(name)\n        const file = await fileHandle.getFile()\n        return new FileResource(file)\n      },\n    }\n  }\n}\n","import { ICustomSongResources } from 'bemuse/resources/types'\nimport { Song } from 'bemuse/collection-model/types'\n\n/* eslint import/no-webpack-loader-syntax: off */\nexport function loadSongFromResources(\n  resources: ICustomSongResources,\n  options: LoadSongOptions = {}\n) {\n  const onMessage = options.onMessage || (() => {})\n  if (resources.setLoggingFunction) {\n    resources.setLoggingFunction(onMessage)\n  }\n  return resources.fileList\n    .then((fileList) => {\n      return loadFromFileList(fileList)\n    })\n    .then((song) => {\n      song.resources = resources\n      return song\n    })\n\n  function loadFromFileList(fileList: string[]) {\n    if (fileList.includes('bemuse-song.json')) {\n      return loadFromBemuseSongJson()\n    } else {\n      const bmsFileList = fileList.filter((filename) =>\n        /\\.(bms|bme|bml|bmson)$/i.test(filename)\n      )\n      return loadFromBmsFileList(bmsFileList)\n    }\n  }\n\n  async function loadFromBemuseSongJson() {\n    onMessage('\"bemuse-song.json\" found...')\n    const file = await resources.file('bemuse-song.json')\n    const data = await file.read()\n    const text = await new Blob([data]).text()\n    const song = JSON.parse(text) as Song\n    return song\n  }\n\n  async function loadFromBmsFileList(bmsFileList: string[]) {\n    onMessage(bmsFileList.length + ' file(s) found. Reading them...')\n    const files = await Promise.all(\n      bmsFileList.map(async (filename) => {\n        const start = Date.now()\n        const file = await resources.file(filename)\n        const data = await file.read()\n        const elapsed = Date.now() - start\n        if (elapsed > 1000) onMessage('Read: ' + filename)\n        return {\n          name: filename,\n          data: data,\n        }\n      })\n    )\n    const song = await new Promise<Song>((resolve, reject) => {\n      const worker = new Worker(\n        // @ts-ignore\n        new URL('./song-loader.worker.js', import.meta.url)\n      )\n      worker.onmessage = function ({ data }) {\n        if (data.type === 'result') {\n          resolve(data.song)\n          worker.terminate()\n        } else if (data.type === 'started') {\n          onMessage('Analyzing BMS files...')\n        } else if (data.type === 'progress') {\n          onMessage(\n            'Loaded ' +\n              data.file +\n              ' ' +\n              '(' +\n              data.current +\n              '/' +\n              data.total +\n              ').'\n          )\n        }\n      }\n      worker.onerror = function (e) {\n        onMessage('Worker error: ' + e)\n        console.error('Worker error: ' + e)\n        reject(e.error)\n      }\n      worker.postMessage({ files })\n    })\n    song.bemusepack_url = null\n    return song\n  }\n}\n\nexport interface LoadSongOptions {\n  onMessage?: (message: string) => void\n}\n","import { INITIAL_OPERATION_STATE, Operation } from './operations'\nimport { Observable, distinct, map, scan } from 'rxjs'\n\nimport Immutable from 'immutable'\n\nexport type Action<T> =\n  | { type: 'PUT'; data: Record<string, Operation<T>> }\n  | { type: 'CLEAR' }\n\nexport function put<T>(id: string, transition: Operation<T>) {\n  return putMultiple({ [id]: transition })\n}\n\nexport function putMultiple<T>(transitions: Record<string, Operation<T>>) {\n  return { type: PUT, data: transitions } as const\n}\n\nexport function clear() {\n  return { type: CLEAR } as const\n}\n\nconst PUT = 'PUT'\nconst CLEAR = 'CLEAR'\n\nexport type DataStore<T> = Immutable.Map<string, Operation<T>>\n\nexport const initialState = <T>(): DataStore<T> =>\n  Immutable.Map<string, Operation<T>>()\n\nexport function store川<T>(\n  action川: Observable<Action<T>>\n): Observable<DataStore<T>> {\n  return action川.pipe(scan(reduce, initialState()))\n}\n\nexport function item川<T>(state川: Observable<DataStore<T>>, id: string) {\n  return state川.pipe(map((state) => get(state, id))).pipe(distinct())\n}\n\nexport function reduce<T>(\n  state: DataStore<T> = initialState(),\n  action: Action<T>\n): DataStore<T> {\n  switch (action.type) {\n    case PUT: {\n      const stateChanges = Immutable.Map(action.data)\n      return state.merge(stateChanges)\n    }\n    case CLEAR: {\n      return initialState<T>()\n    }\n    default: {\n      return state\n    }\n  }\n}\n\nexport function get<T>(state: DataStore<T>, id: string): Operation<T> {\n  return state.get(id, INITIAL_OPERATION_STATE)\n}\n\nexport function has<T>(state: DataStore<T>, id: string) {\n  return state.has(id)\n}\n","export function id({ md5, playMode }) {\n  return `${md5}-${playMode}`\n}\n\nexport default id\n","// Key mapping\n\nexport const MAPPING_MODES = ['KB', 'BM'] as const\nexport const isMappingMode = (str: string): str is MappingMode =>\n  (MAPPING_MODES as readonly string[]).includes(str)\nexport type MappingMode = typeof MAPPING_MODES[number]\n","import { MappingMode, isMappingMode } from 'bemuse/rules/mapping-mode'\n\nimport invariant from 'invariant'\n\nexport interface RecordLevel {\n  md5: string\n  playMode: MappingMode\n}\n\nexport function fromObject({\n  md5,\n  playMode,\n}: {\n  md5?: unknown\n  playMode?: unknown\n}): RecordLevel {\n  invariant(typeof md5 === 'string', 'md5 must be a string')\n  invariant(typeof playMode === 'string', 'playMode must be a string')\n  invariant(isMappingMode(playMode), 'playMode must be a MappingMode')\n  return { md5, playMode }\n}\n","import {\n  Action,\n  DataStore,\n  initialState,\n  put,\n  putMultiple,\n  store川,\n} from './data-store'\nimport {\n  INITIAL_OPERATION_STATE,\n  Operation,\n  completed,\n  operation川FromPromise,\n} from './operations'\nimport {\n  Observable,\n  ObservableInput,\n  Subject,\n  asapScheduler,\n  bufferTime,\n  combineLatest,\n  concatMap,\n  distinctUntilChanged,\n  from,\n  map,\n  merge,\n  of,\n  scan,\n  scheduled,\n  shareReplay,\n  startWith,\n  switchMap,\n} from 'rxjs'\nimport { RecordLevel, fromObject } from './level'\n\nimport Immutable from 'immutable'\nimport { ScoreCount } from 'bemuse/rules/accuracy'\nimport _ from 'lodash'\nimport id from './id'\n\nexport interface SignUpInfo {\n  username: string\n  password: string\n  email: string\n}\n\nexport interface LogInInfo {\n  username: string\n  password: string\n}\n\nexport interface UserInfo {\n  username: string\n}\n\nexport interface ChangePasswordInfo {\n  email: string\n}\n\nexport interface ScoreBase {\n  score: number\n  combo: number\n  count: ScoreCount\n  total: number\n  log: string\n}\n\nexport type ScoreInfo = ScoreBase & RecordLevel\n\nexport type RankingInfo = Partial<ScoreBase> & RecordLevel\n\nconst scoreInfoGuard = (data: ScoreInfo | RankingInfo): data is ScoreInfo =>\n  !!data.score\n\nexport interface ScoreboardDataEntry {\n  rank?: number\n  score: number\n  combo?: number\n  count: ScoreCount\n  total: number\n  playerName: string\n  recordedAt?: Date\n  playCount?: number\n  playNumber?: number\n}\n\nexport type ScoreboardDataRecord = ScoreboardDataEntry & RecordLevel\n\nexport type SubmissionOperation =\n  | Operation<ScoreboardDataEntry | null>\n  | Readonly<{\n      status: 'unauthenticated'\n    }>\n\nexport interface RankingState {\n  data: ScoreboardDataEntry[] | null\n  meta: {\n    submission: SubmissionOperation\n    scoreboard: Operation<ScoreboardDataEntry | null>\n  }\n}\n\nexport interface AccountService {\n  getCurrentUser(): UserInfo | null\n  signUp(signUpInfo: SignUpInfo): Promise<UserInfo | null>\n  logIn(logInInfo: LogInInfo): Promise<UserInfo | null>\n  changePassword(changePasswordInfo: ChangePasswordInfo): Promise<object>\n  logOut(): Promise<void>\n  submitScore(scoreInfo: ScoreInfo): Promise<ScoreboardDataRecord>\n  retrieveRecord(level: RecordLevel): Promise<ScoreboardDataRecord | null>\n  retrieveScoreboard(\n    level: RecordLevel\n  ): Promise<{ data: ScoreboardDataEntry[] }>\n  retrieveMultipleRecords(\n    levels: readonly RecordLevel[]\n  ): Promise<ScoreboardDataRecord[]>\n}\n\nexport interface RankingStream {\n  state川: Observable<RankingState>\n  resubmit: () => void\n  reloadScoreboard: () => void\n}\n\nexport class Online {\n  constructor(private readonly service: AccountService) {}\n\n  private user口 = new Subject<UserInfo | null>()\n  private seen口 = new Subject<RecordLevel>()\n  private submitted口 = new Subject<ScoreboardDataRecord>()\n\n  user川 = this.user口\n    .pipe(startWith(null))\n    .pipe(shareReplay(1))\n    .pipe(map((user) => user || this.service.getCurrentUser()))\n\n  async signUp(options: SignUpInfo) {\n    const user = await this.service.signUp(options)\n    this.user口.next(user)\n    return user\n  }\n\n  async logIn(options: LogInInfo) {\n    const user = await this.service.logIn(options)\n    this.user口.next(user)\n    return user\n  }\n\n  changePassword(options: ChangePasswordInfo) {\n    return Promise.resolve(this.service.changePassword(options))\n  }\n\n  async logOut(): Promise<void> {\n    await this.service.logOut()\n    this.user口.next(null)\n  }\n\n  async submitScore(info: ScoreInfo) {\n    const record = await this.service.submitScore(info)\n    this.submitted口.next(record)\n    return record\n  }\n\n  scoreboard(level: RecordLevel) {\n    return this.service.retrieveScoreboard(level)\n  }\n\n  private allSeen川 = this.allSeen川ForJustSeen川(this.seen口)\n\n  private allSeen川ForJustSeen川(\n    justSeen川: Observable<RecordLevel>\n  ): Observable<RecordLevel[]> {\n    return justSeen川\n      .pipe(bufferTime(138))\n      .pipe(\n        scan(\n          (map, seen) =>\n            map.merge(Immutable.Map(_.zipObject(seen.map(id), seen))),\n          Immutable.Map<string, RecordLevel>()\n        )\n      )\n      .pipe(map((map) => map.valueSeq()))\n      .pipe(distinctUntilChanged(Immutable.is))\n      .pipe(map((seq) => seq.toArray()))\n  }\n\n  private fetchRecords = async (\n    levels: readonly RecordLevel[],\n    user: UserInfo | null,\n    seen: Set<string>\n  ): Promise<Action<ScoreboardDataRecord | null>> => {\n    const levelsToFetch = levels.filter((level) => !seen.has(id(level)))\n    for (const level of levelsToFetch) {\n      seen.add(id(level))\n    }\n    const results =\n      user && levelsToFetch.length > 0\n        ? await this.service.retrieveMultipleRecords(levelsToFetch)\n        : []\n    try {\n      const loadedRecords = _.zipObject(results.map(id), results.map(completed))\n      const nullResults = _.zipObject(\n        levelsToFetch.map(id),\n        levelsToFetch.map(() => completed(null))\n      )\n      const transitions = _.defaults(loadedRecords, nullResults)\n      return putMultiple<ScoreboardDataRecord | null>(transitions)\n    } catch (e: unknown) {\n      console.error('Cannot fetch levels:', e)\n      return putMultiple({})\n    }\n  }\n\n  private records川ForUser = (\n    user: UserInfo | null\n  ): Observable<DataStore<ScoreboardDataRecord | null>> => {\n    const seen = new Set<string>()\n\n    const action川 = merge(\n      this.allSeen川.pipe(\n        concatMap((x) => from(this.fetchRecords(x, user, seen)))\n      ),\n      this.submitted口.pipe(map((record) => put(id(record), completed(record))))\n    )\n    return store川(action川)\n  }\n\n  records川 = this.user川\n    .pipe(switchMap(this.records川ForUser))\n    .pipe(startWith(initialState<ScoreboardDataRecord | null>()))\n    .pipe(shareReplay(1))\n\n  dispose() {}\n\n  Ranking(data: RankingInfo): RankingStream {\n    const level: RecordLevel = fromObject(data)\n    const retrySelf口 = new Subject<void>()\n    const retryScoreboard口 = new Subject<void>()\n\n    const self川 = this.self川ForUser(retrySelf口, data)\n    const scoreboard川 = self川\n      .pipe(\n        switchMap(() => this.getScoreboardState川(retryScoreboard口, level))\n      )\n      .pipe(shareReplay(1))\n    const state川 = combineLatest({\n      self: self川,\n      scoreboard: scoreboard川,\n    }).pipe(map(this.conformState))\n    return {\n      state川,\n      resubmit: () => retrySelf口.next(),\n      reloadScoreboard: () => retryScoreboard口.next(),\n    }\n  }\n\n  // Make the state conform the old API. We should remove this in the future.\n  private conformState = ({\n    self,\n    scoreboard,\n  }: {\n    self: SubmissionOperation\n    scoreboard: Operation<{ data: ScoreboardDataEntry[] }>\n  }): RankingState => ({\n    data:\n      scoreboard.status === 'completed' ? scoreboard.value?.data ?? null : null,\n    meta: {\n      scoreboard: _.omit(scoreboard, 'value') as Operation<ScoreboardDataEntry>,\n      submission: { ...self } as Operation<ScoreboardDataEntry>,\n    },\n  })\n\n  private self川ForUser = (\n    retrySelfBus: Observable<void>,\n    data: ScoreInfo | RankingInfo\n  ): Observable<SubmissionOperation> =>\n    this.user川\n      .pipe(\n        switchMap((user) => {\n          if (!user) {\n            return this.unauthenticatedRankingModel()\n          }\n          if (scoreInfoGuard(data)) {\n            return this.submissionModel(retrySelfBus, data)\n          }\n          return this.viewRecordModel(retrySelfBus, data)\n        })\n      )\n      .pipe(startWith(INITIAL_OPERATION_STATE))\n      .pipe(shareReplay(1))\n\n  private unauthenticatedRankingModel = (): Observable<SubmissionOperation> =>\n    of({\n      status: 'unauthenticated',\n      error: null,\n      record: null,\n    })\n\n  private submissionModel = (\n    retrySelfBus: Observable<void>,\n    data: ScoreInfo\n  ): Observable<SubmissionOperation> =>\n    merge(this.asap川([[]]), retrySelfBus).pipe(\n      switchMap(() => operation川FromPromise(this.submitScore(data)))\n    )\n\n  private viewRecordModel = (\n    retrySelfBus: Observable<void>,\n    data: RankingInfo\n  ): Observable<SubmissionOperation> =>\n    merge(this.asap川([[]]), retrySelfBus).pipe(\n      switchMap(() => operation川FromPromise(this.service.retrieveRecord(data)))\n    )\n\n  private getScoreboardState川 = (\n    retryScoreboardBus: Observable<void>,\n    level: RecordLevel\n  ): Observable<Operation<{ data: ScoreboardDataEntry[] }>> =>\n    merge(this.asap川([[]]), retryScoreboardBus).pipe(\n      switchMap(() => operation川FromPromise(this.scoreboard(level)))\n    )\n\n  private asap川 = <T>(input: ObservableInput<T>) =>\n    scheduled(input, asapScheduler)\n\n  seen(level: RecordLevel) {\n    return this.seen口.next(level)\n  }\n}\n\nexport default Online\n","import { Observable, from, startWith } from 'rxjs'\n\nexport type Pending = {\n  status: 'pending'\n}\n\nexport type Loading = {\n  status: 'loading'\n}\n\nexport type Waiting = Pending | Loading\n\nexport type Completed<T> = {\n  status: 'completed'\n  value: T\n}\n\nexport type Errored = {\n  status: 'error'\n  error: Error\n}\n\n// An asynchronous operation may be in four states:\n//\n// 0. Pending\n// 1. Loading\n// 2. Completed\n// 3. Error\n//\nexport type Operation<T> = Readonly<Waiting | Completed<T> | Errored>\n\n// A constant representing the initial state of an asynchronous operation\n// that may be repeated:\nexport const INITIAL_OPERATION_STATE = {\n  status: 'pending',\n} as const\n\nexport function loading() {\n  return { status: 'loading' } as const\n}\n\nexport function completed<T>(value: T): Operation<T> {\n  return { status: 'completed', value }\n}\n\nexport function error(error: Error) {\n  return { status: 'error', error } as const\n}\n\nexport function transition<T>(\n  previousState: Operation<T> = INITIAL_OPERATION_STATE,\n  transition: Operation<T>\n): Operation<T> {\n  return Object.assign({}, previousState, transition)\n}\n\nexport function isWaiting<T>(state: Operation<T>): state is Waiting {\n  return state.status === 'loading' || state.status === 'pending'\n}\n\n// Returns a Promise representing the outcome of a given promise.\n// This promise will never be rejected, but will always resolve with a state transition object.\nexport function outcomeOfPromise<T>(\n  promise: PromiseLike<T>\n): Promise<Operation<T>> {\n  return Promise.resolve(promise).then(completed, error)\n}\n\nexport function operation川FromPromise<T>(\n  promise: PromiseLike<T>\n): Observable<Operation<T>> {\n  return from(outcomeOfPromise(promise)).pipe(startWith(loading()))\n}\n","import {\n  ScoreboardClient,\n  ScoreboardEntry,\n  ScoreboardRow,\n} from './ScoreboardClient'\n\nimport { MappingMode } from 'bemuse/rules/mapping-mode'\nimport ObjectID from 'bson-objectid'\nimport type { ScoreCount } from 'bemuse/rules/accuracy'\nimport delay from 'delay'\n\ninterface Submission {\n  md5: string\n  playMode: MappingMode\n  entry: ScoreboardEntry\n}\n\nexport function createFakeScoreboardClient(): ScoreboardClient {\n  let submissions: Submission[] = []\n  const signedUpUsernames = new Set<string>()\n\n  const client: ScoreboardClient = {\n    signUp: async (options) => {\n      await delay(100)\n      if (signedUpUsernames.has(options.username)) {\n        throw new Error('Username already taken')\n      }\n      signedUpUsernames.add(options.username)\n      return { playerToken: 'FAKE!' + options.username }\n    },\n    loginByUsernamePassword: async (options) => {\n      await delay(100)\n      return { playerToken: 'FAKE!' + options.username }\n    },\n    changePassword: async (options) => {\n      return {}\n    },\n    renewPlayerToken: async (options) => {\n      return options.playerToken\n    },\n    submitScore: async (options) => {\n      await delay(100)\n      const { username } = decodeFakePlayerToken(options.playerToken)\n      const matching = (s: Submission): boolean =>\n        s.md5 === options.md5 &&\n        s.playMode === options.playMode &&\n        s.entry.player.name === username\n      const existingSubmission = submissions.find(matching)\n      const newScoreboardEntry = updateScoreboardEntry(\n        existingSubmission?.entry,\n        options.input,\n        { name: username }\n      )\n      submissions = submissions.filter((s) => !matching(s))\n      submissions.push({\n        md5: options.md5,\n        playMode: options.playMode,\n        entry: newScoreboardEntry,\n      })\n      return {\n        data: {\n          registerScore: {\n            resultingRow: getRow(options.md5, options.playMode, username)!,\n          },\n        },\n      }\n    },\n    retrieveRankingEntries: async (options) => {\n      if (!options.md5s.every((x) => typeof x === 'string')) {\n        console.error('Invalid md5s...', options.md5s)\n        throw new Error('Invalid md5s (this is a programmer error)')\n      }\n      await delay(100)\n      const { username } = decodeFakePlayerToken(options.playerToken)\n      const set = new Set<string>(options.md5s)\n      return {\n        data: {\n          me: {\n            records: submissions.filter(\n              (s) => set.has(s.md5) && s.entry.player.name === username\n            ),\n          },\n        },\n      }\n    },\n    retrieveRecord: async (options) => {\n      await delay(100)\n      const { username } = decodeFakePlayerToken(options.playerToken)\n      return {\n        data: {\n          chart: {\n            level: {\n              myRecord: getRow(options.md5, options.playMode, username),\n            },\n          },\n        },\n      }\n    },\n    retrieveScoreboard: async (options) => {\n      await delay(100)\n      return {\n        data: {\n          chart: {\n            level: {\n              leaderboard: getChartSubmissions(\n                options.md5,\n                options.playMode\n              ).map((s, i) => ({ rank: i + 1, entry: s.entry })),\n            },\n          },\n        },\n      }\n    },\n  }\n\n  function getRow(\n    md5: string,\n    playMode: string,\n    username: string\n  ): ScoreboardRow | null {\n    const chartSubmissions = getChartSubmissions(md5, playMode)\n    const mySubmission = chartSubmissions.find(\n      (s) => s.entry.player.name === username\n    )\n    if (!mySubmission) {\n      return null\n    }\n    const myRank =\n      chartSubmissions.filter((s) => s.entry.score > mySubmission.entry.score)\n        .length + 1\n    return {\n      rank: myRank,\n      entry: mySubmission.entry,\n    }\n  }\n\n  function getChartSubmissions(md5: string, playMode: string) {\n    return submissions\n      .filter((s) => s.md5 === md5 && s.playMode === playMode)\n      .sort((a, b) => b.entry.score - a.entry.score)\n  }\n\n  return client\n}\n\nfunction decodeFakePlayerToken(token: string) {\n  if (!token.startsWith('FAKE!')) {\n    throw new Error('Invalid player token: ' + token)\n  }\n  return { username: token.replace(/^FAKE!/, '') }\n}\n\nexport interface ScoreData {\n  score: number\n  combo: number\n  count: ScoreCount\n  total: number\n  log: string\n}\n\nexport function updateScoreboardEntry(\n  original: ScoreboardEntry | null | undefined,\n  data: ScoreData,\n  player: { name: string }\n): ScoreboardEntry {\n  const nextPlayCount = (original?.playCount || 0) + 1\n  const score = +data.score\n  if (!original || score > original.score) {\n    return Object.assign({}, original || {}, {\n      id: original?.id || ObjectID.generate(),\n      score: score,\n      playCount: nextPlayCount,\n      playNumber: nextPlayCount,\n      combo: +data.combo || 0,\n      count: [\n        +data.count[0] || 0,\n        +data.count[1] || 0,\n        +data.count[2] || 0,\n        +data.count[3] || 0,\n        +data.count[4] || 0,\n      ] as [number, number, number, number, number],\n      total: +data.total || 0,\n      recordedAt: new Date().toJSON(),\n      player: player,\n    })\n  } else {\n    return Object.assign({}, original, {\n      playCount: nextPlayCount,\n    })\n  }\n}\n","import axios from 'axios'\nimport invariant from 'invariant'\n\nimport { ScoreboardClient, ScoreboardRow } from './ScoreboardClient'\n\nexport interface CreateScoreboardClientOptions {\n  /**\n   * The URL of the scoreboard server.\n   */\n  server: string\n\n  log: unknown\n}\n\nexport function createNextScoreboardClient({\n  server,\n}: CreateScoreboardClientOptions): ScoreboardClient {\n  const client = axios.create({\n    baseURL: server,\n  })\n\n  async function getMyRecord(\n    playerToken: string,\n    md5: string,\n    playMode: string\n  ) {\n    const response = await client\n      .get(`/api/scoreboard/${md5}/${playMode}/mine`, {\n        headers: { Authorization: `Bearer ${playerToken}` },\n      })\n      .catch(handleAxiosError('Unable to retrieve personal records'))\n    return response.data.data as ScoreboardRow\n  }\n\n  const scoreboardClient: ScoreboardClient = {\n    async signUp({ username, password, email }) {\n      invariant(typeof username === 'string', 'username must be a string')\n      invariant(typeof password === 'string', 'password must be a string')\n      invariant(typeof email === 'string', 'email must be a string')\n      const response = await client\n        .post('/api/auth/signup', {\n          username,\n          password,\n          email,\n        })\n        .catch(handleAxiosError('Unable to sign up'))\n      return { playerToken: response.data.playerToken }\n    },\n    async loginByUsernamePassword({ username, password }) {\n      invariant(typeof username === 'string', 'username must be a string')\n      invariant(typeof password === 'string', 'password must be a string')\n      const response = await client\n        .post('/api/auth/login', {\n          username,\n          password,\n        })\n        .catch(handleAxiosError('Unable to log in'))\n      return { playerToken: response.data.playerToken }\n    },\n    async changePassword({ email }) {\n      await client\n        .post('/api/auth/reset', { email })\n        .catch(handleAxiosError('Unable to request password reset'))\n      return {}\n    },\n    async submitScore({ playerToken, md5, playMode, input }) {\n      await client\n        .post(\n          `/api/scoreboard/${md5}/${playMode}/submit`,\n          { scoreData: input },\n          { headers: { Authorization: `Bearer ${playerToken}` } }\n        )\n        .catch(handleAxiosError('Unable to submit score'))\n      return {\n        data: {\n          registerScore: {\n            resultingRow: await getMyRecord(playerToken, md5, playMode),\n          },\n        },\n      }\n    },\n    async retrieveScoreboard({ md5, playMode }) {\n      const response = await client\n        .get(`/api/scoreboard/${md5}/${playMode}/leaderboard`)\n        .catch(handleAxiosError('Unable to retrieve leaderboard'))\n      return {\n        data: {\n          chart: {\n            level: {\n              leaderboard: response.data.data,\n            },\n          },\n        },\n      }\n    },\n    async retrieveRecord({ playerToken, md5, playMode }) {\n      return {\n        data: {\n          chart: {\n            level: {\n              myRecord: await getMyRecord(playerToken, md5, playMode),\n            },\n          },\n        },\n      }\n    },\n    async retrieveRankingEntries({ playerToken, md5s }) {\n      const response = await client\n        .post(\n          `/api/scoreboard/records`,\n          { md5s },\n          { headers: { Authorization: `Bearer ${playerToken}` } }\n        )\n        .catch(handleAxiosError('Unable to retrieve ranking entries'))\n      return {\n        data: {\n          me: {\n            records: response.data.data,\n          },\n        },\n      }\n    },\n    async renewPlayerToken({ playerToken }) {\n      const response = await client\n        .post(\n          '/api/auth/renew',\n          {},\n          {\n            headers: { Authorization: `Bearer ${playerToken}` },\n          }\n        )\n        .catch(handleAxiosError('Unable to renew token'))\n      return response.data.playerToken\n    },\n  }\n\n  return scoreboardClient\n}\nfunction handleAxiosError(prefix: string) {\n  return (error: any): never => {\n    if (axios.isAxiosError(error)) {\n      const data = error.response?.data\n      const message = data?.message\n      const suffix = message ? `: ${message}` : ''\n      if (data) {\n        throw new Error(`${prefix}: ${error}${suffix}`)\n      }\n    }\n    throw error\n  }\n}\n","import type {\n  AccountService,\n  ChangePasswordInfo,\n  LogInInfo,\n  ScoreInfo,\n  ScoreboardDataEntry,\n  SignUpInfo,\n} from '..'\nimport { ScoreboardClient, ScoreboardRow } from './ScoreboardClient'\n\nimport { RecordLevel } from '../level'\nimport { createFakeScoreboardClient } from './createFakeScoreboardClient'\nimport { createNextScoreboardClient } from './createNextScoreboardClient'\nimport { isTestModeEnabled } from 'bemuse/devtools/BemuseTestMode'\n\nexport interface OnlineServiceOptions {\n  fake?: boolean\n  server?: string\n  storagePrefix?: string\n  storage?: Storage\n}\n\ninterface User {\n  username: string\n  playerToken: string\n}\n\nexport class OnlineService implements AccountService {\n  private _isFake: boolean\n  private _scoreboardClient: ScoreboardClient\n  private _storage: Storage\n  private _storagePrefix: string\n  private _currentUser: User | undefined\n\n  constructor({\n    fake = false,\n    server,\n    storagePrefix = fake ? 'fake-scoreboard.auth' : 'scoreboard.auth',\n    storage = localStorage,\n  }: OnlineServiceOptions) {\n    this._isFake = fake\n    this._scoreboardClient =\n      fake || !server\n        ? createFakeScoreboardClient()\n        : createNextScoreboardClient({ server, log: () => {} })\n    this._storage = storage\n    this._storagePrefix = storagePrefix\n    this._updateUserFromStorage()\n    this._renewPlayerToken()\n  }\n\n  _updateUserFromStorage() {\n    const loadUser = (text: string | null) => {\n      if (!text) return null\n      try {\n        const data = JSON.parse(text)\n        const playerToken = data.playerToken\n        const playerTokenExpires = playerToken.startsWith('FAKE!')\n          ? Date.now() + 86400e3 * 7\n          : JSON.parse(atob(playerToken.split('.')[1])).exp * 1000\n        if (Date.now() > playerTokenExpires - 86400e3) {\n          console.warn('Authentication token is about to expire, skipping!')\n          return null\n        }\n        return data\n      } catch (e) {\n        return null\n      }\n    }\n    this._currentUser = loadUser(\n      this._storage.getItem(`${this._storagePrefix}.id`)\n    )\n  }\n\n  _renewPlayerToken() {\n    if (!this._currentUser) {\n      return\n    }\n    const { playerToken, username } = this._currentUser\n    return this._scoreboardClient\n      .renewPlayerToken({ playerToken })\n      .then((newToken) => {\n        if (this._storage.getItem(`${this._storagePrefix}.id`)) {\n          this._storage.setItem(\n            `${this._storagePrefix}.id`,\n            JSON.stringify({\n              username: username,\n              playerToken: newToken,\n            })\n          )\n        }\n      })\n  }\n\n  getCurrentUser() {\n    if (this._currentUser && this._currentUser.playerToken) {\n      return { username: this._currentUser.username }\n    } else {\n      return null\n    }\n  }\n\n  isLoggedIn() {\n    return !!this._currentUser\n  }\n\n  signUp({ username, password, email }: SignUpInfo) {\n    return this._scoreboardClient\n      .signUp({ username, password, email })\n      .then((signUpResult) => {\n        this._storage.setItem(\n          `${this._storagePrefix}.id`,\n          JSON.stringify({\n            username: username,\n            playerToken: signUpResult.playerToken,\n          })\n        )\n        this._updateUserFromStorage()\n        return this.getCurrentUser()\n      })\n  }\n\n  logIn({ username, password }: LogInInfo) {\n    return this._scoreboardClient\n      .loginByUsernamePassword({ username, password })\n      .then((loginResult) => {\n        this._storage.setItem(\n          `${this._storagePrefix}.id`,\n          JSON.stringify({\n            username: username,\n            playerToken: loginResult.playerToken,\n          })\n        )\n        this._updateUserFromStorage()\n        return this.getCurrentUser()\n      })\n  }\n\n  changePassword({ email }: ChangePasswordInfo) {\n    return this._scoreboardClient.changePassword({ email })\n  }\n\n  async logOut() {\n    this._storage.removeItem(`${this._storagePrefix}.id`)\n    this._updateUserFromStorage()\n  }\n\n  async submitScore(info: ScoreInfo) {\n    if (isTestModeEnabled() && !this._isFake) {\n      throw new Error('Cannot submit score in test mode')\n    }\n    if (!this._currentUser) {\n      throw new Error('Not logged in')\n    }\n    const result = await this._scoreboardClient.submitScore({\n      playerToken: this._currentUser.playerToken,\n      md5: info.md5,\n      playMode: info.playMode,\n      input: {\n        score: info.score,\n        combo: info.combo,\n        count: info.count,\n        total: info.total,\n        log: info.log,\n      },\n    })\n    const data = {\n      md5: info.md5,\n      playMode: info.playMode,\n      ...toEntry(result.data.registerScore.resultingRow),\n    }\n    return data\n  }\n\n  // Retrieves a record.\n  //\n  // Returns a record object.\n  async retrieveRecord(level: RecordLevel) {\n    if (!this._currentUser) {\n      throw new Error('Not logged in')\n    }\n    const result = await this._scoreboardClient.retrieveRecord({\n      playerToken: this._currentUser.playerToken,\n      md5: level.md5,\n      playMode: level.playMode,\n    })\n    const myRecord = result.data.chart.level.myRecord\n    return (\n      myRecord && {\n        md5: level.md5,\n        playMode: level.playMode,\n        ...toEntry(myRecord),\n      }\n    )\n  }\n\n  // Retrieves the scoreboard\n  async retrieveScoreboard({ md5, playMode }: RecordLevel) {\n    const result = await this._scoreboardClient.retrieveScoreboard({\n      md5,\n      playMode,\n    })\n    return { data: result.data.chart.level.leaderboard.map(toEntry) }\n  }\n\n  // Retrieve multiple records!\n  //\n  // Items is an array of song items. They have a md5 property.\n  async retrieveMultipleRecords(items: readonly RecordLevel[]) {\n    if (!this._currentUser) {\n      throw new Error('Not logged in')\n    }\n    const result = await this._scoreboardClient.retrieveRankingEntries({\n      playerToken: this._currentUser.playerToken,\n      md5s: items.map((item) => item.md5),\n    })\n    const entries = result.data.me.records.map((item) => ({\n      ...toEntry(item),\n      md5: item.md5,\n      playMode: item.playMode,\n    }))\n    return entries\n  }\n}\n\nexport default OnlineService\n\nfunction toEntry(row: ScoreboardRow): ScoreboardDataEntry {\n  return {\n    rank: row.rank,\n    score: row.entry.score,\n    combo: row.entry.combo,\n    count: row.entry.count,\n    total: row.entry.total,\n    playerName: row.entry.player.name,\n    recordedAt: new Date(row.entry.recordedAt),\n    playCount: row.entry.playCount,\n    playNumber: row.entry.playNumber,\n  }\n}\n"],"names":["deltas","meticulousWindow","preciseWindow","sum","delta","difference","Math","abs","CustomFolderContextImpl","get","set","del","CUSTOM_FOLDER_KEYVAL_KEY","async","setCustomFolder","context","folder","handle","clearCustomFolder","getCustomFolderState","getDefaultCustomFolderContext","scanFolder","io","state","log","setStatus","updateState","i","result","scanIteration","nextState","moreIterationsNeeded","chartFilesScanned","inputState","message","permission","queryPermission","mode","requestPermission","checkFolderStateAndPermissions","foldersToUpdate","length","n","songsToSave","updatedPathSet","Set","deadline","Date","now","entries","add","JSON","stringify","path","pathStr","formatPath","remaining","statusPrefix","resources","getResourcesForFolder","chartFiles","_unused","song","onMessage","text","charts","push","songsToSavePathSet","map","newSongs","songs","filter","has","newFoldersToUpdate","updateFolders","foldersToRemove","remainingSongs","removedPathSet","includes","newFoldersToRemove","removeFolders","chartFileScanner","ChartFileScanner","searchForChartFiles","newChartFiles","getNewChartFiles","getFoldersToUpdate","getFoldersToRemove","getFolderCount","join","scanAllChartFiles","directoryHandle","parentPath","entriesRead","name","childPath","kind","test","fileHandle","addPath","getModifiedDate","getFile","lastModified","error","console","rootFolderHandle","folderHandle","getFolderHandleByPath","files","file","every","p","fileList","Promise","resolve","getFileHandle","getDirectoryHandle","constructor","previous","fast","foundFolderSet","updatedFolderSet","changedPaths","this","existingMap","Map","existingFolderSet","slice","key","folderKey","existing","parse","size","getSongsFromCustomFolders","customFolderSongs","resourceFactory","CustomFolderResourceFactory","out","customFolderSong","getResources","custom","id","e","getGrant","Error","getFolderHandle","loadSongFromResources","options","setLoggingFunction","then","data","read","Blob","loadFromBemuseSongJson","bmsFileList","all","filename","start","reject","worker","Worker","URL","onmessage","type","terminate","current","total","onerror","postMessage","bemusepack_url","loadFromBmsFileList","loadFromFileList","put","transition","putMultiple","transitions","PUT","clear","CLEAR","initialState","pipe","reduce","action","stateChanges","merge","md5","playMode","MAPPING_MODES","fromObject","str","service","Subject","startWith","shareReplay","user","getCurrentUser","fetchRecords","levels","seen","levelsToFetch","level","results","retrieveMultipleRecords","loadedRecords","nullResults","concatMap","x","from","record","switchMap","conformState","self","scoreboard","status","value","meta","submission","retrySelfBus","score","scoreInfoGuard","submissionModel","viewRecordModel","unauthenticatedRankingModel","of","submitScore","retrieveRecord","retryScoreboardBus","input","scheduled","asap","signUp","next","logIn","changePassword","logOut","info","retrieveScoreboard","bufferTime","scan","valueSeq","distinctUntilChanged","seq","toArray","dispose","Ranking","combineLatest","resubmit","reloadScoreboard","INITIAL_OPERATION_STATE","loading","completed","isWaiting","promise","outcomeOfPromise","createFakeScoreboardClient","submissions","signedUpUsernames","getRow","username","chartSubmissions","getChartSubmissions","mySubmission","find","s","entry","player","rank","sort","a","b","playerToken","loginByUsernamePassword","renewPlayerToken","decodeFakePlayerToken","matching","existingSubmission","newScoreboardEntry","original","nextPlayCount","playCount","Object","assign","playNumber","combo","count","recordedAt","toJSON","updateScoreboardEntry","registerScore","resultingRow","retrieveRankingEntries","md5s","me","records","chart","myRecord","leaderboard","token","startsWith","replace","handleAxiosError","prefix","axios","response","fake","server","storagePrefix","storage","localStorage","_isFake","_scoreboardClient","client","baseURL","getMyRecord","headers","Authorization","catch","password","email","post","scoreData","createNextScoreboardClient","_storage","_storagePrefix","_updateUserFromStorage","_renewPlayerToken","_currentUser","playerTokenExpires","atob","split","exp","warn","loadUser","getItem","newToken","setItem","isLoggedIn","signUpResult","loginResult","removeItem","isTestModeEnabled","toEntry","items","item","row","playerName"],"sourceRoot":""}