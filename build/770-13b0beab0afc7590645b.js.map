{"version":3,"file":"build/770-13b0beab0afc7590645b.js","mappings":"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","sources":["file:///home/runner/work/bemuse/bemuse/bemuse/src/app/entities/Collections.js","file:///home/runner/work/bemuse/bemuse/bemuse/src/app/entities/LoadState.js","file:///home/runner/work/bemuse/bemuse/bemuse/src/app/entities/MusicSearchText.js","file:///home/runner/work/bemuse/bemuse/bemuse/src/app/entities/MusicSelection.js","file:///home/runner/work/bemuse/bemuse/bemuse/src/app/entities/Options.js","file:///home/runner/work/bemuse/bemuse/bemuse/src/app/interactors/getLR2Score.js","file:///home/runner/work/bemuse/bemuse/bemuse/src/app/options.js","file:///home/runner/work/bemuse/bemuse/bemuse/src/music-collection/filterSongs.js","file:///home/runner/work/bemuse/bemuse/bemuse/src/app/redux/createReducer.js","file:///home/runner/work/bemuse/bemuse/bemuse/src/app/redux/ReduxState.js","file:///home/runner/work/bemuse/bemuse/bemuse/src/custom-folder/index.ts","file:///home/runner/work/bemuse/bemuse/bemuse/src/custom-song-loader/index.ts","file:///home/runner/work/bemuse/bemuse/bemuse/src/music-collection/getPlayableCharts.js","file:///home/runner/work/bemuse/bemuse/bemuse/src/music-collection/SongOfTheDay.ts","file:///home/runner/work/bemuse/bemuse/bemuse/src/music-collection/groupSongsIntoCategories.js","file:///home/runner/work/bemuse/bemuse/bemuse/src/music-collection/isChartPlayable.js","file:///home/runner/work/bemuse/bemuse/bemuse/src/music-collection/preprocessCollection.js","file:///home/runner/work/bemuse/bemuse/bemuse/src/music-collection/sortSongs.js","file:///home/runner/work/bemuse/bemuse/bemuse/src/online/data-store.js","file:///home/runner/work/bemuse/bemuse/bemuse/src/online/id.js","file:///home/runner/work/bemuse/bemuse/bemuse/src/online/index.js","file:///home/runner/work/bemuse/bemuse/bemuse/src/online/level.js","file:///home/runner/work/bemuse/bemuse/bemuse/src/online/operations.js","file:///home/runner/work/bemuse/bemuse/bemuse/src/online/scoreboard-system/createNextScoreboardClient.ts","file:///home/runner/work/bemuse/bemuse/bemuse/src/online/scoreboard-system/createFakeScoreboardClient.ts","file:///home/runner/work/bemuse/bemuse/bemuse/src/online/scoreboard-system/OnlineService.js"],"sourcesContent":["import Immutable from 'immutable'\nimport * as LoadState from './LoadState'\n\nexport const initialState = Immutable.Map()\n\nexport const beginLoading = (url) => (state) =>\n  state.set(url, LoadState.initLoading())\n\nexport const completeLoading = (url, data) => (state) =>\n  state.update(url, LoadState.completeWithValue(data))\n\nexport const errorLoading = (url, error) => (state) =>\n  state.update(url, LoadState.errorWithReason(error))\n\nexport const getCollectionByUrl = (url) => (state) => state.get(url)\n","// An entity that represents something that can have a loading state.\nimport produce from 'immer'\n\n// Initializers\nexport const initLoading = () => ({ status: 'loading' })\nexport const initCompletedWithValue = (value) => ({\n  status: 'completed',\n  value,\n})\n\n// Queries\nexport const isLoading = (state) => state.status === 'loading'\nexport const isCompleted = (state) => state.status === 'completed'\nexport const isError = (state) => state.status === 'error'\nexport const value = (state) => state.value\nexport const error = (state) => isError(state) && state.error\n\n// State Updaters\nexport const beginLoading = (state) => initLoading()\n\nexport const completeWithValue = (value) =>\n  produce((draft) => {\n    draft.status = 'completed'\n    draft.value = value\n  })\n\nexport const errorWithReason = (error) =>\n  produce((draft) => {\n    draft.status = 'error'\n    draft.error = error\n  })\n","import produce from 'immer'\n\n// Initializers\nexport const initWithText = (text) => ({\n  staged: text,\n  committed: text,\n})\n\n// Default initial state\nexport const initialState = initWithText('')\n\n// Queries\nexport const searchText = (state) => state.committed\nexport const inputText = (state) => state.staged\n\n// Updaters\nexport const handleTextType = (text) =>\n  produce((draft) => {\n    draft.staged = text\n  })\nexport const handleDebounce = (state) => ({ ...state, committed: state.staged })\nexport const setText = (text) => () => initWithText(text)\n","import produce from 'immer'\nimport _ from 'lodash'\n\nexport const initialState = {\n  selectedSongId: null,\n  selectedChartId: null,\n  selectedChartLevel: 1,\n}\n\n// Queries\nexport const selectedSongGivenSongs = (songs) => (state) => {\n  const song = _.find(songs, { id: state.selectedSongId })\n  if (song) return song\n  return songs[0]\n}\nexport const selectedChartGivenCharts = (charts) => (state) => {\n  charts = charts || []\n  const chart = _.find(charts, { file: state.selectedChartId })\n  if (chart) return chart\n  return _.minBy(charts, (chart) =>\n    Math.abs(getChartLevel(chart) - state.selectedChartLevel)\n  )\n}\n\n// Updater\nexport const selectSong = (songId) =>\n  produce((draft) => {\n    draft.selectedSongId = songId\n  })\nexport const selectChart = (songId, chartId, chartLevel) =>\n  produce((draft) => {\n    draft.selectedSongId = songId\n    draft.selectedChartId = chartId\n    draft.selectedChartLevel = chartLevel\n  })\n\n// Utilities\nexport function getChartLevel(chart) {\n  return chart.info.level + (chart.info.difficulty === 5 ? 1000 : 0)\n}\n","import _ from 'lodash'\nimport produce from 'immer'\n\nimport * as options from '../options'\n\n// Initializers\nexport const initialState = options.DEFAULTS\nexport const initWithDataFromStorage = (options) => ({\n  ...initialState,\n  ...options,\n})\n\n// Internal utils\nconst toggleOptionEnabled = (value) => value === '1'\nconst toggleOption = (value) => (toggleOptionEnabled(value) ? '0' : '1')\n\n// Key mapping\nexport const getKeyMapping = (mode, key) => (state) =>\n  state['input.P1.keyboard.' + mode + '.' + key]\nexport const changeKeyMapping = (mode, key, keyCode) =>\n  produce((draft) => {\n    draft['input.P1.keyboard.' + mode + '.' + key] = keyCode\n  })\n\n// Play mode\nexport const playMode = (state) => state['player.P1.mode']\nexport const changePlayMode = (mode) =>\n  produce((draft) => {\n    draft['player.P1.mode'] = mode\n    draft['player.P1.panel'] =\n      draft['player.P1.panel'] === '3d' && mode !== 'KB'\n        ? 'center'\n        : draft['player.P1.panel']\n  })\n\n// Speed\nexport const speed = (state) => state['player.P1.speed']\nexport const changeSpeed = (speed) =>\n  produce((draft) => {\n    draft['player.P1.speed'] = speed\n  })\n\n// Lead time\nexport const leadTime = (state) => {\n  const parsed = parseInt(state['player.P1.lead-time'], 10)\n  if (!parsed) return 1685\n  if (parsed < 138) return 138\n  return parsed\n}\nexport const changeLeadTime = (leadTime) =>\n  produce((draft) => {\n    draft['player.P1.lead-time'] = leadTime\n  })\n\n// Scratch position\nexport const scratchPosition = (state) => {\n  if (state['player.P1.mode'] === 'KB') {\n    return 'off'\n  } else {\n    return state['player.P1.scratch']\n  }\n}\nexport const changeScratchPosition = (position) => {\n  if (position === 'off') {\n    return changePlayMode('KB')\n  } else {\n    return _.flow(\n      changePlayMode('BM'),\n      produce((draft) => {\n        draft['player.P1.scratch'] = position\n      })\n    )\n  }\n}\n\n// Panel\nexport const panelPlacement = (state) => state['player.P1.panel']\nexport const changePanelPlacement = (placement) =>\n  produce((draft) => {\n    draft['player.P1.panel'] = placement\n    draft['player.P1.mode'] =\n      placement === '3d' && draft['player.P1.mode'] !== 'KB'\n        ? 'KB'\n        : draft['player.P1.mode']\n  })\n\n// Lane cover\nexport const laneCover = (state) => {\n  return (\n    Math.min(\n      50,\n      Math.max(-50, Math.round(state['player.P1.lane-cover'] * 100))\n    ) / 100 || 0\n  )\n}\nexport const changeLaneCover = (laneCover) =>\n  produce((draft) => {\n    draft['player.P1.lane-cover'] = laneCover\n  })\n\n// BGA\nexport const isBackgroundAnimationsEnabled = (state) =>\n  toggleOptionEnabled(state['system.bga.enabled'])\nexport const toggleBackgroundAnimations = produce((draft) => {\n  draft['system.bga.enabled'] = toggleOption(draft['system.bga.enabled'])\n})\n\n// Auto-velocity\nexport const isAutoVelocityEnabled = (state) =>\n  toggleOptionEnabled(state['player.P1.auto-velocity'])\nexport const toggleAutoVelocity = produce((draft) => {\n  draft['player.P1.auto-velocity'] = toggleOption(\n    draft['player.P1.auto-velocity']\n  )\n})\n\n// Song preview enabled\nexport const isPreviewEnabled = (state) =>\n  toggleOptionEnabled(state['system.preview.enabled'])\nexport const togglePreview = produce((draft) => {\n  draft['system.preview.enabled'] = toggleOption(\n    draft['system.preview.enabled']\n  )\n})\n\n// Gauge\nexport const isGaugeEnabled = (state) => getGauge(state) !== 'off'\nexport const getGauge = (state) => state['player.P1.gauge']\nexport const toggleGauge = produce((draft) => {\n  draft['player.P1.gauge'] = draft['player.P1.gauge'] === 'off' ? 'hope' : 'off'\n})\n\n// Queries\nexport const keyboardMapping = (state) => {\n  const mapping = {}\n  for (const control of ['1', '2', '3', '4', '5', '6', '7', 'SC', 'SC2']) {\n    const key = 'input.P1.keyboard.' + playMode(state) + '.' + control\n    mapping[control] = state[key] || ''\n  }\n  return mapping\n}\n\n// Feature acknowledgements\nexport const hasAcknowledged = (featureKey) => (state) =>\n  state[`system.ack.${featureKey}`] === '1'\nexport const acknowledge = (featureKey) =>\n  produce((draft) => {\n    draft[`system.ack.${featureKey}`] = '1'\n  })\n\n// Audio-input latency\nexport const audioInputLatency = (state) => +state['system.offset.audio-input']\nexport const changeAudioInputLatency = (latency) =>\n  produce((draft) => {\n    draft['system.offset.audio-input'] = `${latency}`\n  })\n\n// Gamepad Continuous Axis\nexport const isContinuousAxisEnabled = (state) =>\n  toggleOptionEnabled(state['gamepad.continuous'])\nexport const toggleContinuousAxis = produce((draft) => {\n  draft['gamepad.continuous'] = toggleOption(draft['gamepad.continuous'])\n})\n\n// Gamepad Sensitivity\nexport const sensitivity = (state) => state['gamepad.sensitivity']\nexport const changeSensitivity = (sensitivity) =>\n  produce((draft) => {\n    draft['gamepad.sensitivity'] = sensitivity\n  })\n\n// Latest version\nexport const lastSeenVersion = (state) => state['system.last-seen-version']\nexport const updateLastSeenVersion = (newVersion) =>\n  produce((draft) => {\n    draft['system.last-seen-version'] = newVersion\n  })\n\n// Utils\nexport const nextKeyToEdit = (editing, scratch) => {\n  const keySet = (() => {\n    if (scratch === 'left') {\n      return ['SC', 'SC2', '1', '2', '3', '4', '5', '6', '7']\n    } else if (scratch === 'right') {\n      return ['1', '2', '3', '4', '5', '6', '7', 'SC', 'SC2']\n    } else {\n      return ['1', '2', '3', '4', '5', '6', '7']\n    }\n  })()\n  const index = keySet.indexOf(editing)\n  if (index < 0) return null\n  return keySet[index + 1] || null\n}\n","// Calculates the score as if it was computed by LR2.\n//\n// - `deltas` The array representing the player’s delta offsets in **seconds**.\n// - `timegates` A 2-tuple containing **millisecond values**:\n//     - `[0]` The timegate for PGREAT judgment.\n//     - `[1]` The timegate for GREAT judgment.\n//\n// This module is implemented so that we can compare the difficulty\n// of grading system in Bemuse to Lunatic Rave 2’s.\n//\nexport function getLR2Score(deltas, [meticulousWindow, preciseWindow]) {\n  let sum = 0\n  for (const delta of deltas) {\n    const difference = Math.abs(delta) * 1000\n    if (difference < meticulousWindow) sum += 1\n    if (difference < preciseWindow) sum += 1\n  }\n  return sum\n}\n\nexport default getLR2Score\n","import { EventEmitter } from 'events'\n\nlet storage = localStorage\n\n// The structure of this may change in the future, so I'll keep this private.\nexport const DEFAULTS = {\n  // Game mode (KB, BM)\n  'player.P1.mode': 'KB',\n\n  // Keyboard mapping\n  'input.P1.keyboard.BM.SC': '16',\n  'input.P1.keyboard.BM.SC2': '65',\n  'input.P1.keyboard.BM.1': '90',\n  'input.P1.keyboard.BM.2': '83',\n  'input.P1.keyboard.BM.3': '88',\n  'input.P1.keyboard.BM.4': '68',\n  'input.P1.keyboard.BM.5': '67',\n  'input.P1.keyboard.BM.6': '70',\n  'input.P1.keyboard.BM.7': '86',\n\n  'input.P1.keyboard.KB.1': '83',\n  'input.P1.keyboard.KB.2': '68',\n  'input.P1.keyboard.KB.3': '70',\n  'input.P1.keyboard.KB.4': '32',\n  'input.P1.keyboard.KB.5': '74',\n  'input.P1.keyboard.KB.6': '75',\n  'input.P1.keyboard.KB.7': '76',\n\n  // Note speed\n  'player.P1.speed': '1.0',\n  'player.P1.lane-cover': '0',\n  'player.P1.lead-time': '1685',\n  'player.P1.auto-velocity': '0',\n\n  // Scratch placement (left, right, off)\n  'player.P1.scratch': 'left',\n\n  // Panel placement (left, center, right)\n  'player.P1.panel': 'center',\n\n  // Gauge type (off, hope)\n  'player.P1.gauge': 'off',\n\n  // Gamepad settings\n  'gamepad.continuous': '0',\n  'gamepad.sensitivity': '4',\n\n  // Offsets\n  'system.offset.audio-input': '0',\n  'system.offset.audio-visual': '0',\n\n  // BGA\n  'system.bga.enabled': '1',\n  'system.preview.enabled': '1',\n\n  // Version\n  'system.last-seen-version': '0.0.0',\n\n  // Acknowledgements (guide texts)\n  'system.ack.twitter': '0',\n  'system.ack.deltas': '0',\n  'system.ack.finishGame': '0',\n  'system.ack.replayGame': '0',\n}\n\nexport const events = new EventEmitter()\n\n// Returns all the available options.\nexport function keys() {\n  return Object.keys(DEFAULTS)\n}\n\n// Gets the options value by a specified key.\nexport function get(key) {\n  return storage.getItem(key) || DEFAULTS[key]\n}\n\n// Saves the options value by a specified key.\nexport function set(key, value) {\n  storage.setItem(key, value)\n  events.emit('changed')\n}\n\n// Saves many options.\nexport function setOptions(options) {\n  for (const key of Object.keys(options)) {\n    storage.setItem(key, options[key])\n  }\n  events.emit('changed')\n}\n\n// Gets the options Storage engine.\nexport function getStorage() {\n  return storage\n}\n\n// Returns all the options.\nexport function getAllCurrentOptions() {\n  const options = {}\n  for (const key of keys()) options[key] = get(key)\n  return options\n}\n\n// Sets the options Storage engine.\n// Useful for injecting a mock storage from tests. A storage engine should have\n// ``getItem`` and ``setItem`` methods. An example of a storage engine\n// that implements this interface is the ``localStorage``.\nexport function setStorage(_storage) {\n  storage = _storage\n}\n\n// Upgrades the options from previous versions\n// v1.0.0-beta.7 - split game into modes : BM and KB\nif (get('player.P1.scratch') === 'off') {\n  set('player.P1.scratch', 'left')\n}\n","export function filterSongs(songs, filterText) {\n  return songs.filter((song) => matches(song, filterText))\n}\n\nfunction matches(song, filterText) {\n  if (!filterText) return true\n  return (\n    contains(song.title, filterText) ||\n    contains(song.artist, filterText) ||\n    contains(song.genre, filterText)\n  )\n}\n\nfunction contains(haystack, needle) {\n  return String(haystack.toLowerCase()).indexOf(needle.toLowerCase()) >= 0\n}\n\nexport default filterSongs\n","export default createReducer\n\nexport function createReducer(initialState, handlers) {\n  return (state = initialState, action) => {\n    const nextState = handlers[action.type]\n      ? handlers[action.type](action)(state)\n      : state\n    return nextState\n  }\n}\n","// This module defines the state shape, behavior, and actions of the Redux store.\n//\n// - Use action constants to create actions. They are in past tense, describing\n//   what happened.\n// - The reducers are used to apply the action to the state. Domain logic should\n//   not be here. Instead, put them in entities.\n// - The selectors can be used to query data from the store.\n//\n\nimport _ from 'lodash'\nimport filterSongs from 'bemuse/music-collection/filterSongs'\nimport getPlayableCharts from 'bemuse/music-collection/getPlayableCharts'\nimport groupSongsIntoCategories from 'bemuse/music-collection/groupSongsIntoCategories'\nimport preprocessCollection from 'bemuse/music-collection/preprocessCollection'\nimport sortSongs from 'bemuse/music-collection/sortSongs'\nimport { combineReducers } from 'redux'\nimport { createSelector } from 'reselect'\n\nimport * as Collections from '../entities/Collections'\nimport * as LoadState from '../entities/LoadState'\nimport * as MusicSearchText from '../entities/MusicSearchText'\nimport * as MusicSelection from '../entities/MusicSelection'\nimport * as Options from '../entities/Options'\nimport createReducer from './createReducer'\n\n// Actions\nexport const COLLECTION_LOADING_BEGAN = 'COLLECTION_LOADING_BEGAN'\nexport const COLLECTION_LOADING_ERRORED = 'COLLECTION_LOADING_ERRORED'\nexport const COLLECTION_LOADED = 'COLLECTION_LOADED'\nexport const CUSTOM_SONG_LOAD_STARTED = 'CUSTOM_SONG_LOAD_STARTED'\nexport const CUSTOM_SONG_LOADED = 'CUSTOM_SONG_LOADED'\nexport const CUSTOM_SONGS_LOADED = 'CUSTOM_SONGS_LOADED'\nexport const MUSIC_SEARCH_TEXT_TYPED = 'MUSIC_SEARCH_TEXT_TYPED'\nexport const MUSIC_SEARCH_TEXT_INITIALIZED = 'MUSIC_SEARCH_TEXT_INITIALIZED'\nexport const MUSIC_SEARCH_DEBOUNCED = 'MUSIC_SEARCH_DEBOUNCED'\nexport const MUSIC_SONG_SELECTED = 'MUSIC_SONG_SELECTED'\nexport const MUSIC_CHART_SELECTED = 'MUSIC_CHART_SELECTED'\nexport const OPTIONS_LOADED_FROM_STORAGE = 'OPTIONS_LOADED_FROM_STORAGE'\nexport const README_LOADING_STARTED = 'README_LOADING_STARTED'\nexport const README_LOADED = 'README_LOADED'\nexport const README_LOADING_ERRORED = 'README_LOADING_ERRORED'\nexport const RAGEQUITTED = 'RAGEQUITTED'\nexport const RAGEQUIT_DISMISSED = 'RAGEQUIT_DISMISSED'\n\n// Reducer\nexport const reducer = combineReducers({\n  collections: createReducer(Collections.initialState, {\n    [COLLECTION_LOADING_BEGAN]: (action) =>\n      Collections.beginLoading(action.url),\n    [COLLECTION_LOADING_ERRORED]: (action) =>\n      Collections.completeLoading(action.url, action.error),\n    [COLLECTION_LOADED]: (action) =>\n      Collections.completeLoading(action.url, action.data),\n  }),\n  customSongLoadState: createReducer(LoadState.initCompletedWithValue(null), {\n    [CUSTOM_SONG_LOAD_STARTED]: (action) => LoadState.beginLoading,\n    [CUSTOM_SONG_LOADED]: (action) => LoadState.completeWithValue(),\n  }),\n  customSongs: createReducer([], {\n    [CUSTOM_SONG_LOADED]: (action) => (state) => [action.song],\n    [CUSTOM_SONGS_LOADED]: (action) => (state) => action.songs,\n  }),\n  currentCollection: createReducer('', {\n    [COLLECTION_LOADING_BEGAN]: (action) => (state) =>\n      state === '' ? action.url : state,\n  }),\n  musicSearchText: createReducer(MusicSearchText.initialState, {\n    [MUSIC_SEARCH_TEXT_TYPED]: (action) =>\n      MusicSearchText.handleTextType(action.text),\n    [MUSIC_SEARCH_DEBOUNCED]: (action) => MusicSearchText.handleDebounce,\n    [MUSIC_SEARCH_TEXT_INITIALIZED]: (action) =>\n      MusicSearchText.setText(action.text),\n  }),\n  musicSelection: createReducer(MusicSelection.initialState, {\n    [CUSTOM_SONG_LOADED]: (action) => MusicSelection.selectSong(action.song.id),\n    [MUSIC_SONG_SELECTED]: (action) => MusicSelection.selectSong(action.songId),\n    [MUSIC_CHART_SELECTED]: (action) =>\n      MusicSelection.selectChart(\n        action.songId,\n        action.chartId,\n        action.chartLevel\n      ),\n  }),\n  options: createReducer(Options.initialState, {\n    [OPTIONS_LOADED_FROM_STORAGE]: (action) => (state) =>\n      Options.initWithDataFromStorage(action.options),\n  }),\n  currentSongReadme: createReducer('Omachi kudasai…', {\n    [README_LOADING_STARTED]: (action) => (state) => 'Omachi kudasai…',\n    [README_LOADING_ERRORED]: (action) => (state) =>\n      'Cannot download ' + action.url,\n    [README_LOADED]: (action) => (state) => action.text,\n  }),\n  rageQuit: createReducer(false, {\n    [RAGEQUITTED]: (action) => (state) => true,\n    [RAGEQUIT_DISMISSED]: (action) => (state) => false,\n  }),\n})\n\n// Selectors\nexport const selectCurrentCollectionUrl = (state) => state.currentCollection\n\nexport const selectCurrentCollection = createSelector(\n  (state) => state.collections,\n  selectCurrentCollectionUrl,\n  (collections, currentCollection) =>\n    Collections.getCollectionByUrl(currentCollection)(collections)\n)\n\nexport const selectIsCurrentCollectionLoading = (state) =>\n  LoadState.isLoading(selectCurrentCollection(state))\n\nexport const selectCurrentCorrectionLoadError = (state) =>\n  LoadState.error(selectCurrentCollection(state))\n\nexport const selectRawCurrentCollectionValue = (state) =>\n  LoadState.value(selectCurrentCollection(state))\n\nexport const selectCurrentCollectionValue = createSelector(\n  selectRawCurrentCollectionValue,\n  (collection) => collection && preprocessCollection(collection)\n)\n\nexport const selectSearchInputText = (state) =>\n  MusicSearchText.inputText(state.musicSearchText)\n\nexport const selectSearchText = (state) =>\n  MusicSearchText.searchText(state.musicSearchText)\n\nexport const { selectGroups, selectSongs } = (() => {\n  const selectSongListFromCurrentCollection = createSelector(\n    selectCurrentCollectionValue,\n    (collectionData) => (collectionData && collectionData.songs) || []\n  )\n  const selectSongList = createSelector(\n    selectSongListFromCurrentCollection,\n    (state) => state.customSongs,\n    (songList, customSongs) => [...customSongs, ...songList]\n  )\n  const selectSortedSongList = createSelector(selectSongList, (songList) =>\n    sortSongs(songList)\n  )\n  const selectFilteredSongList = createSelector(\n    selectSortedSongList,\n    selectSearchText,\n    (songList, searchText) => filterSongs(songList, searchText)\n  )\n  const selectSongOfTheDayEnabled = createSelector(\n    selectCurrentCollectionValue,\n    (collectionData) => collectionData && collectionData.songOfTheDayEnabled\n  )\n  const selectGroups = createSelector(\n    selectFilteredSongList,\n    selectSongOfTheDayEnabled,\n    (songs, songOfTheDayEnabled) =>\n      groupSongsIntoCategories(songs, {\n        songOfTheDayEnabled,\n      })\n  )\n  const selectSongs = createSelector(selectGroups, (groups) =>\n    _(groups).map('songs').flatten().value()\n  )\n  return { selectGroups, selectSongs }\n})()\n\nexport const {\n  selectSelectedSong,\n  selectChartsForSelectedSong,\n  selectSelectedChart,\n} = (() => {\n  const selectMusicSelection = (state) => state.musicSelection\n  const selectSelectedSong = createSelector(\n    selectMusicSelection,\n    selectSongs,\n    (musicSelection, songs) =>\n      MusicSelection.selectedSongGivenSongs(songs)(musicSelection)\n  )\n  const selectChartsForSelectedSong = createSelector(\n    selectSelectedSong,\n    (song) => getPlayableCharts((song && song.charts) || [])\n  )\n  const selectSelectedChart = createSelector(\n    selectMusicSelection,\n    selectChartsForSelectedSong,\n    (musicSelection, charts) =>\n      MusicSelection.selectedChartGivenCharts(charts)(musicSelection)\n  )\n  return {\n    selectSelectedSong,\n    selectChartsForSelectedSong,\n    selectSelectedChart,\n  }\n})()\n\nexport const selectReadmeTextForSelectedSong = (state) =>\n  state.currentSongReadme\n\nexport const selectPlayMode = (store) => Options.playMode(store.options)\n\nexport const selectRageQuittedFlag = (store) => store.rageQuit\n","import _ from 'lodash'\nimport { get, set, del } from 'idb-keyval'\nimport pMemoize from 'p-memoize'\nimport {\n  CustomFolderChartFile,\n  CustomFolderFolderEntry,\n  CustomFolderSong,\n  CustomFolderState,\n} from './types'\nimport { loadSongFromResources } from 'bemuse/custom-song-loader'\nimport { ICustomSongResources, IResources } from 'bemuse/resources/types'\nimport { FileResource } from 'bemuse/resources/custom-song-resources'\nimport { Song } from 'bemuse/collection-model/types'\n\nexport interface CustomFolderContext {\n  get: (key: string) => Promise<CustomFolderState | undefined>\n  set: (key: string, value: CustomFolderState) => Promise<void>\n  del: (key: string) => Promise<void>\n}\n\nexport class CustomFolderContextImpl implements CustomFolderContext {\n  get = get\n  set = set\n  del = del\n}\n\nconst CUSTOM_FOLDER_KEYVAL_KEY = 'custom-folder-1'\n\nexport async function setCustomFolder(\n  context: CustomFolderContext,\n  folder: FileSystemDirectoryHandle\n) {\n  await context.set(CUSTOM_FOLDER_KEYVAL_KEY, {\n    handle: folder,\n  })\n}\n\nexport async function clearCustomFolder(context: CustomFolderContext) {\n  await context.del(CUSTOM_FOLDER_KEYVAL_KEY)\n}\n\nexport async function getCustomFolderState(context: CustomFolderContext) {\n  return context.get(CUSTOM_FOLDER_KEYVAL_KEY)\n}\n\nexport const getDefaultCustomFolderContext = _.once(\n  () => new CustomFolderContextImpl()\n)\n\nexport type CustomFolderScanIO = {\n  log: (message: string) => void\n  setStatus: (message: string) => void\n  updateState: (state: CustomFolderState) => void\n}\n\nexport async function scanFolder(\n  context: CustomFolderContext,\n  io: CustomFolderScanIO\n) {\n  let state = await getCustomFolderState(context)\n  const { log, setStatus, updateState } = io\n  for (let i = 1; ; i++) {\n    log(`Iteration #${i} start`)\n    const result = await scanIteration(state, io)\n\n    // If there is nothing to be done in the very first iteration, let’s rescan the folder for new chart files.\n    if (!result && i === 1) {\n      state = { ...state, chartFilesScanned: false }\n      continue\n    }\n\n    if (!result) {\n      break\n    }\n    if (result.nextState) {\n      state = result.nextState\n      updateState(state)\n      setStatus(`Saving state (iteration #${i})`)\n      await context.set(CUSTOM_FOLDER_KEYVAL_KEY, state)\n    }\n    if (!result.moreIterationsNeeded) {\n      break\n    }\n  }\n  setStatus('Done scanning.')\n}\n\nasync function scanIteration(\n  inputState: CustomFolderState | undefined,\n  io: CustomFolderScanIO\n): Promise<ScanIterationResult | undefined> {\n  const result = await checkFolderStateAndPermissions(inputState, io)\n  if (!result) {\n    return\n  }\n  const { state, handle } = result\n\n  if (!state.chartFilesScanned) {\n    return scanAllChartFiles(state, handle, io)\n  }\n\n  if ((state?.foldersToUpdate?.length ?? 0) > 0) {\n    return updateFolders(state, handle, io)\n  }\n\n  if ((state?.foldersToRemove?.length ?? 0) > 0) {\n    return removeFolders(state, handle, io)\n  }\n}\n\nasync function checkFolderStateAndPermissions(\n  state: CustomFolderState | undefined,\n  io: CustomFolderScanIO\n): Promise<\n  | {\n      state: CustomFolderState\n      handle: FileSystemDirectoryHandle\n    }\n  | undefined\n> {\n  const { log, setStatus } = io\n  if (!state) {\n    const message = 'No custom folder set.'\n    log(message)\n    setStatus(message)\n    return\n  }\n\n  const { handle } = state\n  if (!handle) {\n    const message = 'No folder selected.'\n    log(message)\n    setStatus(message)\n    return\n  }\n\n  let permission = await handle.queryPermission({ mode: 'read' })\n  if (permission === 'prompt') {\n    setStatus('Waiting for permission — please grant access to the folder.')\n    permission = await handle.requestPermission({ mode: 'read' })\n  }\n  if (permission !== 'granted') {\n    log('Unable to read the folder due to lack of permissions.')\n    setStatus('Unable to read the folder due to lack of permissions.')\n    return\n  }\n\n  return { state, handle }\n}\n\nasync function scanAllChartFiles(\n  state: CustomFolderState,\n  handle: FileSystemDirectoryHandle,\n  io: CustomFolderScanIO\n): Promise<ScanIterationResult | undefined> {\n  const { log, setStatus } = io\n  const chartFileScanner = new ChartFileScanner(state.chartFiles, true)\n  await searchForChartFiles(handle, chartFileScanner, io)\n\n  const newChartFiles = chartFileScanner.getNewChartFiles()\n  const foldersToUpdate = chartFileScanner.getFoldersToUpdate()\n  const foldersToRemove = chartFileScanner.getFoldersToRemove()\n  const message =\n    'Scanning done. ' +\n    [\n      `Charts: ${newChartFiles.length}`,\n      `Folders: ${chartFileScanner.getFolderCount()}`,\n      `Folders to update: ${foldersToUpdate.length}`,\n      `Folders to remove: ${foldersToRemove.length}`,\n    ].join('; ')\n  log(message)\n  setStatus(message)\n\n  return {\n    nextState: {\n      ...state,\n      chartFiles: newChartFiles,\n      chartFilesScanned: true,\n      foldersToUpdate,\n      foldersToRemove,\n    },\n    moreIterationsNeeded: true,\n  }\n}\n\nasync function searchForChartFiles(\n  directoryHandle: FileSystemDirectoryHandle,\n  chartFileScanner: ChartFileScanner,\n  io: CustomFolderScanIO,\n  parentPath: string[] = []\n): Promise<void> {\n  let entriesRead = 0\n  const { log, setStatus } = io\n  for await (const [name, handle] of directoryHandle) {\n    const childPath = [...parentPath, name]\n    try {\n      if (handle.kind === 'directory') {\n        await searchForChartFiles(handle, chartFileScanner, io, childPath)\n      } else if (/\\.(bms|bme|bml|bmson)$/i.test(name)) {\n        const fileHandle = handle\n        await chartFileScanner.addPath(childPath, {\n          getModifiedDate: async () => {\n            const file = await fileHandle.getFile()\n            return file.lastModified\n          },\n        })\n      }\n    } catch (error) {\n      log(`Error while processing ${childPath.join('/')}: ${error}`)\n      console.error(error)\n    }\n    entriesRead++\n    const childPathStr = formatPath(childPath)\n    setStatus(\n      `Scanning for chart files. ${entriesRead} entries read. Just processed: ${childPathStr}`\n    )\n  }\n}\n\nasync function updateFolders(\n  state: CustomFolderState,\n  handle: FileSystemDirectoryHandle,\n  io: CustomFolderScanIO\n): Promise<ScanIterationResult | undefined> {\n  const { log, setStatus } = io\n  if ((state?.foldersToUpdate?.length || 0) > 0) {\n    const foldersToUpdate = [...state.foldersToUpdate!]\n    const n = foldersToUpdate.length\n    const songsToSave: CustomFolderSong[] = []\n    const updatedPathSet = new Set<string>()\n    const deadline = Date.now() + 5000\n\n    for (const [i, folder] of foldersToUpdate.entries()) {\n      updatedPathSet.add(JSON.stringify(folder.path))\n\n      const pathStr = formatPath(folder.path)\n      const remaining = n - i\n      log(`Updating folder “${pathStr}” (${remaining} remaining)`)\n      const statusPrefix = `Folder “${pathStr}” (${remaining} remaining)`\n      setStatus(statusPrefix)\n\n      const resources = await getResourcesForFolder(\n        handle,\n        folder.path,\n        state.chartFiles || []\n      )\n      const { resources: _unused, ...song } = await loadSongFromResources(\n        resources,\n        {\n          onMessage: (text) => {\n            log(text)\n            setStatus(`${statusPrefix} ${text}`)\n          },\n        }\n      )\n      if (song.charts.length > 0) {\n        songsToSave.push({\n          path: folder.path,\n          song,\n        })\n      }\n      if (Date.now() > deadline) {\n        break\n      }\n    }\n\n    const songsToSavePathSet = new Set(\n      songsToSave.map((song) => JSON.stringify(song.path))\n    )\n    const newSongs = [\n      ...(state.songs || []).filter(\n        (song) => !songsToSavePathSet.has(JSON.stringify(song.path))\n      ),\n      ...songsToSave,\n    ]\n    const newFoldersToUpdate = foldersToUpdate.filter(\n      (folder) => !updatedPathSet.has(JSON.stringify(folder.path))\n    )\n    return {\n      nextState: {\n        ...state,\n        foldersToUpdate: newFoldersToUpdate,\n        songs: newSongs,\n      },\n      moreIterationsNeeded: true,\n    }\n  }\n}\n\nasync function removeFolders(\n  state: CustomFolderState,\n  handle: FileSystemDirectoryHandle,\n  io: CustomFolderScanIO\n): Promise<ScanIterationResult | undefined> {\n  const { log, setStatus } = io\n\n  if ((state.foldersToRemove?.length ?? 0) > 0) {\n    let remainingSongs = state.songs || []\n    const foldersToRemove = [...state.foldersToRemove!]\n    const n = foldersToRemove.length\n    const removedPathSet = new Set<string>()\n    const deadline = Date.now() + 5000\n\n    for (const [i, folder] of foldersToRemove.entries()) {\n      removedPathSet.add(JSON.stringify(folder.path))\n\n      const pathStr = formatPath(folder.path)\n      const remaining = n - i\n      log(`Removing folder “${pathStr}” (${remaining} remaining)`)\n      const statusPrefix = `Folder “${pathStr}” (${remaining} remaining)`\n      setStatus(statusPrefix)\n\n      remainingSongs = remainingSongs.filter((song) => {\n        return !song.path.includes(pathStr)\n      })\n\n      if (Date.now() > deadline) break\n    }\n\n    const newFoldersToRemove = foldersToRemove.filter(\n      (folder) => !removedPathSet.has(JSON.stringify(folder.path))\n    )\n    return {\n      nextState: {\n        ...state,\n        foldersToRemove: newFoldersToRemove,\n        songs: remainingSongs,\n      },\n      moreIterationsNeeded: true,\n    }\n  }\n}\n\nasync function getResourcesForFolder(\n  rootFolderHandle: FileSystemDirectoryHandle,\n  path: string[],\n  chartFiles: CustomFolderChartFile[]\n): Promise<ICustomSongResources> {\n  const folderHandle = await getFolderHandleByPath(rootFolderHandle, path)\n  const files = chartFiles.filter(\n    (file) =>\n      file.path.length === path.length + 1 &&\n      path.every((p, i) => p === file.path[i])\n  )\n  return {\n    fileList: Promise.resolve(\n      files.map((file) => file.path[file.path.length - 1])\n    ),\n    async file(name) {\n      const fileHandle = await folderHandle.getFileHandle(name)\n      const file = await fileHandle.getFile()\n      return new FileResource(file)\n    },\n  }\n}\n\nasync function getFolderHandleByPath(\n  rootFolderHandle: FileSystemDirectoryHandle,\n  path: string[]\n): Promise<FileSystemDirectoryHandle> {\n  let handle = rootFolderHandle\n  for (const name of path) {\n    handle = await handle.getDirectoryHandle(name)\n  }\n  return handle\n}\n\ntype ScanIterationResult = {\n  nextState?: CustomFolderState\n  moreIterationsNeeded: boolean\n}\n\nclass ChartFileScanner {\n  private existingMap: Map<string, CustomFolderChartFile>\n  private existingFolderSet: Set<string>\n  private foundFolderSet = new Set<string>()\n  private updatedFolderSet = new Set<string>()\n  private newChartFiles: CustomFolderChartFile[] = []\n  private changedPaths: { path: string[]; lastModified: number }[] = []\n\n  constructor(\n    private previous: CustomFolderState['chartFiles'] = [],\n    private fast = false\n  ) {\n    this.existingMap = new Map(\n      _.map(this.previous, (file) => [JSON.stringify(file.path), file])\n    )\n    this.existingFolderSet = new Set(\n      _.map(this.previous, (file) => JSON.stringify(file.path.slice(0, -1)))\n    )\n  }\n\n  async addPath(\n    childPath: string[],\n    io: {\n      getModifiedDate: () => Promise<number>\n    }\n  ) {\n    const key = JSON.stringify(childPath)\n    const folderKey = JSON.stringify(childPath.slice(0, -1))\n    const existing = this.existingMap.get(key)\n    this.foundFolderSet.add(folderKey)\n    if (existing) {\n      if (!this.fast) {\n        const lastModified = await io.getModifiedDate()\n        if (lastModified > existing.lastModified) {\n          this.changedPaths.push({ path: childPath, lastModified })\n          this.newChartFiles.push({ path: childPath, lastModified })\n          this.updatedFolderSet.add(folderKey)\n        } else {\n          this.newChartFiles.push(existing)\n        }\n      } else {\n        this.newChartFiles.push(existing)\n      }\n    } else {\n      const lastModified = await io.getModifiedDate()\n      this.changedPaths.push({ path: childPath, lastModified })\n      this.newChartFiles.push({ path: childPath, lastModified })\n      this.updatedFolderSet.add(folderKey)\n    }\n  }\n\n  getNewChartFiles() {\n    return this.newChartFiles\n  }\n\n  getFoldersToUpdate(): CustomFolderFolderEntry[] {\n    return [...this.updatedFolderSet].map((folderKey) => ({\n      path: JSON.parse(folderKey) as string[],\n    }))\n  }\n\n  getFoldersToRemove(): CustomFolderFolderEntry[] {\n    return [...this.existingFolderSet]\n      .filter((folderKey) => !this.foundFolderSet.has(folderKey))\n      .map((folderKey) => ({\n        path: JSON.parse(folderKey) as string[],\n      }))\n  }\n\n  getFolderCount() {\n    return this.foundFolderSet.size\n  }\n}\nfunction formatPath(childPath: string[]) {\n  return childPath.join('¥')\n}\n\nexport async function getSongsFromCustomFolders(\n  context: CustomFolderContext\n): Promise<Song[]> {\n  const state = await getCustomFolderState(context)\n  if (!state || !state.handle) {\n    return []\n  }\n\n  const customFolderSongs = state.songs || []\n  const resourceFactory = new CustomFolderResourceFactory(state.handle)\n  const out: Song[] = []\n  for (const [i, customFolderSong] of customFolderSongs.entries()) {\n    try {\n      const resources = resourceFactory.getResources(customFolderSong.path)\n      out.push({\n        ...customFolderSong.song,\n        resources,\n        custom: true,\n        id: `__custom_${i}`,\n      })\n    } catch (e) {\n      console.error(e)\n    }\n  }\n  return out\n}\n\nclass CustomFolderResourceFactory {\n  constructor(private rootFolderHandle: FileSystemDirectoryHandle) {}\n  getGrant = pMemoize(async () => {\n    const handle = this.rootFolderHandle\n    let permission = await handle.queryPermission({ mode: 'read' })\n    if (permission === 'prompt') {\n      permission = await handle.requestPermission({ mode: 'read' })\n    }\n    if (permission !== 'granted') {\n      throw new Error('Permission has not been granted')\n    }\n    return permission\n  })\n\n  getResources(path: string[]): IResources {\n    const getFolderHandle = pMemoize(async () => {\n      await this.getGrant()\n      return getFolderHandleByPath(this.rootFolderHandle, path)\n    })\n    return {\n      async file(name) {\n        const folder = await getFolderHandle()\n        const fileHandle = await folder.getFileHandle(name)\n        const file = await fileHandle.getFile()\n        return new FileResource(file)\n      },\n    }\n  }\n}\n","import { ICustomSongResources } from 'bemuse/resources/types'\nimport { Song } from 'bemuse/collection-model/types'\n\n/* eslint import/no-webpack-loader-syntax: off */\nexport function loadSongFromResources(\n  resources: ICustomSongResources,\n  options: LoadSongOptions = {}\n) {\n  const onMessage = options.onMessage || (() => {})\n  if (resources.setLoggingFunction) {\n    resources.setLoggingFunction(onMessage)\n  }\n  return resources.fileList\n    .then((fileList) => {\n      return loadFromFileList(fileList)\n    })\n    .then((song) => {\n      song.resources = resources\n      return song\n    })\n\n  function loadFromFileList(fileList: string[]) {\n    if (fileList.includes('bemuse-song.json')) {\n      return loadFromBemuseSongJson()\n    } else {\n      const bmsFileList = fileList.filter((filename) =>\n        /\\.(bms|bme|bml|bmson)$/i.test(filename)\n      )\n      return loadFromBmsFileList(bmsFileList)\n    }\n  }\n\n  async function loadFromBemuseSongJson() {\n    onMessage('\"bemuse-song.json\" found...')\n    const file = await resources.file('bemuse-song.json')\n    const data = await file.read()\n    const text = await new Blob([data]).text()\n    const song = JSON.parse(text) as Song\n    return song\n  }\n\n  async function loadFromBmsFileList(bmsFileList: string[]) {\n    onMessage(bmsFileList.length + ' file(s) found. Reading them...')\n    const files = await Promise.all(\n      bmsFileList.map(async (filename) => {\n        const start = Date.now()\n        const file = await resources.file(filename)\n        const data = await file.read()\n        const elapsed = Date.now() - start\n        if (elapsed > 1000) onMessage('Read: ' + filename)\n        return {\n          name: filename,\n          data: data,\n        }\n      })\n    )\n    const song = await new Promise<Song>((resolve, reject) => {\n      const worker = new Worker(\n        // @ts-ignore\n        new URL('./song-loader.worker.js', import.meta.url)\n      )\n      worker.onmessage = function ({ data }) {\n        if (data.type === 'result') {\n          resolve(data.song)\n          worker.terminate()\n        } else if (data.type === 'started') {\n          onMessage('Analyzing BMS files...')\n        } else if (data.type === 'progress') {\n          onMessage(\n            'Loaded ' +\n              data.file +\n              ' ' +\n              '(' +\n              data.current +\n              '/' +\n              data.total +\n              ').'\n          )\n        }\n      }\n      worker.onerror = function (e) {\n        onMessage('Worker error: ' + e)\n        console.error('Worker error: ' + e)\n        reject(e.error)\n      }\n      worker.postMessage({ files })\n    })\n    song.bemusepack_url = null\n    return song\n  }\n}\n\nexport interface LoadSongOptions {\n  onMessage?: (message: string) => void\n}\n","import _ from 'lodash'\n\nimport isChartPlayable from './isChartPlayable'\n\nexport function getPlayableCharts(charts) {\n  return _(charts)\n    .filter(isChartPlayable)\n    .orderBy([\n      (chart) => (chart.info.difficulty >= 5 ? 1 : 0),\n      (chart) => chart.keys,\n      (chart) => chart.info.level,\n    ])\n    .value()\n}\n\nexport default getPlayableCharts\n","import _ from 'lodash'\nimport { createHash } from 'crypto'\nimport { Song } from 'bemuse/collection-model/types'\n\nconst getHashFunction = _.once(() => {\n  const today = new Date(Date.now() + 9 * 3600e3).toISOString().split('T')[0]\n  return _.memoize((id: string) => {\n    const md5 = createHash('md5')\n    md5.update(id)\n    md5.update(today)\n    return md5.digest('hex')\n  })\n})\n\nexport class SongOfTheDay {\n  private ids: Set<string>\n  constructor(songs: Song[], { enabled = true } = {}) {\n    if (!enabled) {\n      this.ids = new Set()\n      return\n    }\n\n    const sorted = _.sortBy(\n      songs.filter((s) => !s.custom && !s.tutorial),\n      (s) => getHashFunction()(s.id)\n    )\n    this.ids = new Set(sorted.slice(0, 3).map((s) => s.id))\n  }\n\n  isSongOfTheDay(id: string) {\n    return this.ids.has(id)\n  }\n}\n","import _ from 'lodash'\nimport { SongOfTheDay } from './SongOfTheDay'\n\nconst grouping = [\n  { title: 'Custom Song', criteria: (song) => song.custom },\n  { title: 'Tutorial', criteria: (song) => song.tutorial },\n  { title: 'Unreleased', criteria: (song) => song.unreleased },\n  {\n    title: 'Recently Added Songs',\n    criteria: (song) =>\n      song.added && Date.now() - Date.parse(song.added) < 60 * 86400000,\n    sort: (song) => song.added,\n    reverse: true,\n  },\n  {\n    title: 'Random Songs of the Day',\n    criteria: (song, context) => context.songOfTheDay.isSongOfTheDay(song.id),\n  },\n  { title: '☆', criteria: () => true },\n]\n\nexport function groupSongsIntoCategories(\n  songs,\n  { songOfTheDayEnabled = false } = {}\n) {\n  const context = {\n    songOfTheDay: new SongOfTheDay(songs, { enabled: songOfTheDayEnabled }),\n  }\n  const groups = grouping.map((group) => ({\n    input: group,\n    output: { title: group.title, songs: [] },\n  }))\n  for (const song of songs) {\n    for (const { input, output } of groups) {\n      if (input.criteria(song, context)) {\n        output.songs.push(song)\n        break\n      }\n    }\n  }\n  for (const { input, output } of groups) {\n    if (input.sort) {\n      output.songs = _.orderBy(\n        output.songs,\n        [input.sort],\n        [input.reverse ? 'desc' : 'asc']\n      )\n    } else if (input.reverse) {\n      output.songs.reverse()\n    }\n  }\n  return _(groups)\n    .map('output')\n    .filter((group) => group.songs.length > 0)\n    .value()\n}\n\nexport default groupSongsIntoCategories\n","export function isChartPlayable(chart) {\n  return chart.keys === '7K' || chart.keys === '5K'\n}\n\nexport default isChartPlayable\n","import produce from 'immer'\n\nexport const preprocessCollection = produce((draft, songs) => {\n  if (songs) {\n    draft.songs = songs.map((song) => preprocessSong(song))\n  }\n})\n\nfunction preprocessSong(song) {\n  if (song.chart_names) {\n    song = produce(song, (draft) => {\n      if (draft.charts) {\n        draft.charts = draft.charts.map((chart) => {\n          const name = song.chart_names[chart.file]\n          if (!name) return chart\n          return produce(chart, (draft) => {\n            draft.info = {\n              subtitles: (subtitles) => [...subtitles, name],\n            }\n          })\n        })\n      }\n    })\n  }\n  return song\n}\n\nexport default preprocessCollection\n","import _ from 'lodash'\nimport isChartPlayable from './isChartPlayable'\n\nexport function sortSongs(songs) {\n  return _.orderBy(songs, [\n    (song) => {\n      return _(song.charts)\n        .filter(isChartPlayable)\n        .filter((chart) => chart.info.difficulty < 5)\n        .filter((chart) => chart.info.level > 0)\n        .map((chart) => chart.info.level)\n        .min()\n    },\n    (song) => song.bpm,\n    (song) => song.title.toLowerCase(),\n  ])\n}\n\nexport default sortSongs\n","import * as Immutable from 'immutable'\n\nimport { INITIAL_OPERATION_STATE, transitionState } from './operations'\n\nconst PUT = 'PUT'\nconst CLEAR = 'CLEAR'\n\nexport const INITIAL_STATE = new Immutable.Map()\n\nexport function store川(action川) {\n  return action川.scan(INITIAL_STATE, reduce)\n}\n\nexport function item川(state川, id) {\n  return state川.map((state) => get(state, id)).skipDuplicates()\n}\n\nexport function reduce(state = INITIAL_STATE, action) {\n  switch (action.type) {\n    case PUT: {\n      const stateChanges = new Immutable.Map(action.data).map(\n        performTransition(state)\n      )\n      return state.merge(stateChanges)\n    }\n    case CLEAR: {\n      return INITIAL_STATE\n    }\n    default: {\n      return state\n    }\n  }\n}\n\nfunction performTransition(state) {\n  return (transition, id) => transitionState(get(state, id), transition)\n}\n\nexport function get(state, id) {\n  return state.get(id, INITIAL_OPERATION_STATE)\n}\n\nexport function has(state, id) {\n  return state.has(id)\n}\n\nexport function put(id, transition) {\n  return putMultiple(new Immutable.Map([[id, transition]]))\n}\n\nexport function putMultiple(transitions) {\n  return { type: PUT, data: transitions }\n}\n\nexport function clear() {\n  return { type: CLEAR }\n}\n","export function id({ md5, playMode }) {\n  return `${md5}-${playMode}`\n}\n\nexport default id\n","import * as DataStore from './data-store'\nimport * as Level from './level'\n\nimport {\n  INITIAL_OPERATION_STATE,\n  completedStateTransition,\n  isWaiting,\n  operationState川,\n  transition川FromPromise,\n} from './operations'\n\nimport Bacon from 'baconjs'\nimport Immutable from 'immutable'\nimport _ from 'lodash'\nimport id from './id'\n\nexport function Online(service) {\n  const user口 = new Bacon.Bus()\n  const seen口 = new Bacon.Bus()\n  const submitted口 = new Bacon.Bus()\n\n  const user川 = user口\n    // https://github.com/baconjs/bacon.js/issues/536\n    .toProperty(null)\n    .map((user) => user || service.getCurrentUser())\n\n  async function signUp(options) {\n    const user = await service.signUp(options)\n    user口.push(user)\n    return user\n  }\n\n  async function logIn(options) {\n    const user = await service.logIn(options)\n    user口.push(user)\n    return user\n  }\n\n  function changePassword(options) {\n    return Promise.resolve(service.changePassword(options))\n  }\n\n  function logOut() {\n    return service.logOut().then(() => user口.push(null))\n  }\n\n  async function submitScore(info) {\n    const record = await service.submitScore(info)\n    submitted口.push(record)\n    return record\n  }\n\n  function getScoreboard(level) {\n    return service.retrieveScoreboard(level)\n  }\n\n  const allSeen川 = allSeen川ForJustSeen川(seen口)\n  const records川 = user川\n    .flatMapLatest(records川ForUser)\n    .toProperty(DataStore.INITIAL_STATE)\n\n  const dispose = records川.onValue(() => {})\n\n  function allSeen川ForJustSeen川(justSeen川) {\n    return justSeen川\n      .bufferWithTime(138)\n      .scan(new Immutable.Map(), (map, seen) =>\n        map.merge(_.zipObject(seen.map(id), seen))\n      )\n      .map((map) => map.valueSeq())\n      .skipDuplicates(Immutable.is)\n      .map((seq) => seq.toJS())\n  }\n\n  function records川ForUser(user) {\n    const seen = {}\n\n    {\n      const action川 = Bacon.mergeAll(\n        // Need to convert a property to EventStream to work around the\n        // first-subscriber-only problem.\n        allSeen川.toEventStream().delay(0).flatMap(fetch),\n        submitted口.map((record) =>\n          DataStore.put(id(record), completedStateTransition(record))\n        )\n      )\n      return DataStore.store川(action川)\n    }\n\n    function fetch(levels) {\n      const levelsToFetch = levels.filter((level) => !seen[id(level)])\n      for (const level of levelsToFetch) {\n        seen[id(level)] = true\n      }\n      const promise =\n        user && levelsToFetch.length > 0\n          ? service.retrieveMultipleRecords(levelsToFetch)\n          : Promise.resolve([])\n      return Bacon.fromPromise(\n        promise\n          .then(function (results) {\n            const loadedRecords = _.zipObject(\n              results.map(id),\n              results.map(completedStateTransition)\n            )\n            const nullResults = _.zipObject(\n              levelsToFetch.map(id),\n              levelsToFetch.map(() => completedStateTransition(null))\n            )\n            const transitions = _.defaults(loadedRecords, nullResults)\n            return DataStore.putMultiple(transitions)\n          })\n          .catch(function (e) {\n            console.error('Cannot fetch levels:', e)\n            return DataStore.putMultiple({})\n          })\n      )\n    }\n  }\n\n  function Ranking(data) {\n    const level = Level.fromObject(data)\n    const retrySelf口 = new Bacon.Bus()\n    const retryScoreboard口 = new Bacon.Bus()\n\n    {\n      const rankingModel川 = user川.map(rankingModelForUser)\n      const self川 = rankingModel川\n        .flatMapLatest((model) => model.self川)\n        .toProperty(INITIAL_OPERATION_STATE)\n      const scoreboardTrigger川 = rankingModel川.flatMapLatest(\n        (model) => model.scoreboardTrigger川\n      )\n      const scoreboard川 = getScoreboardState川(scoreboardTrigger川)\n      const state川 = Bacon.combineTemplate({\n        self: self川,\n        scoreboard: scoreboard川,\n      }).map(conformState)\n      return {\n        state川,\n        resubmit: () => retrySelf口.push(),\n        reloadScoreboard: () => retryScoreboard口.push(),\n      }\n    }\n\n    // Make the state conform the old API. We should remove this in the future.\n    function conformState(state) {\n      return {\n        data: state.scoreboard.value && state.scoreboard.value.data,\n        meta: {\n          scoreboard: _.omit(state.scoreboard, 'value'),\n          submission: state.self,\n        },\n      }\n    }\n\n    function rankingModelForUser(user) {\n      if (!user) return unauthenticatedRankingModel()\n      return data.score ? submissionModel(user) : viewRecordModel(user)\n    }\n\n    function unauthenticatedRankingModel() {\n      return {\n        self川: Bacon.constant({\n          status: 'unauthenticated',\n          error: null,\n          record: null,\n        }),\n        scoreboardTrigger川: Bacon.once({ force: false }),\n      }\n    }\n\n    function submissionModel(user) {\n      const self川 = submitScoreState川(user)\n      const selfDone川 = self川\n        .toEventStream()\n        .filter((state) => !isWaiting(state))\n      return {\n        self川,\n        scoreboardTrigger川: selfDone川.map(() => ({ force: true })),\n      }\n    }\n\n    function viewRecordModel(user) {\n      return {\n        self川: getRecordState川(user),\n        scoreboardTrigger川: asap川({ force: false }),\n      }\n    }\n\n    function getScoreboardState川(trigger川) {\n      return operationState川(\n        trigger川\n          .merge(retryScoreboard口)\n          .flatMapLatest(() => transition川FromPromise(getScoreboard(level)))\n      )\n    }\n\n    function getRecordState川(user) {\n      return operationState川(\n        asap川()\n          .merge(retrySelf口)\n          .flatMapLatest(() =>\n            transition川FromPromise(service.retrieveRecord(level, user))\n          )\n      )\n    }\n\n    function submitScoreState川(user) {\n      return operationState川(\n        asap川()\n          .merge(retrySelf口)\n          .flatMapLatest(() => transition川FromPromise(submitScore(data)))\n      )\n    }\n  }\n\n  function seen(level) {\n    return seen口.push(level)\n  }\n\n  function asap川(value) {\n    return Bacon.later(0, value)\n  }\n\n  return {\n    user川,\n    records川,\n    signUp,\n    logIn,\n    logOut,\n    changePassword,\n    submitScore,\n    scoreboard: getScoreboard,\n    Ranking,\n    seen,\n    dispose,\n  }\n}\n\nexport default Online\n","import invariant from 'invariant'\n\nexport function fromObject({ md5, playMode }) {\n  invariant(typeof md5 === 'string', 'md5 must be a string')\n  invariant(typeof playMode === 'string', 'playMode must be a string')\n  return { md5, playMode }\n}\n","import Bacon from 'baconjs'\n\n// An asynchronous operation may be in four states:\n//\n// 0. Pending\n// 1. Loading\n// 2. Completed\n// 3. Error\n//\n\n// A constant representing the initial state of an asynchronous operation\n// that may be repeated:\nexport const INITIAL_OPERATION_STATE = {\n  status: 'pending',\n  value: null,\n  error: null,\n}\n\nexport function loadingStateTransition() {\n  return { status: 'loading', error: null }\n}\n\nexport function completedStateTransition(value) {\n  return { status: 'completed', value, error: null }\n}\n\nexport function errorStateTransition(error) {\n  return { status: 'error', error }\n}\n\nexport function transitionState(\n  previousState = INITIAL_OPERATION_STATE,\n  transition\n) {\n  return Object.assign({}, previousState, transition)\n}\n\nexport function isWaiting(state) {\n  return state.status === 'loading' || state.status === 'pending'\n}\n\n// Returns a Promise representing the outcome of a given promise.\n// This promise will never be rejected, but will always resolve with a state transition object.\nexport function outcomeOfPromise(promise) {\n  return Promise.resolve(promise).then(\n    completedStateTransition,\n    errorStateTransition\n  )\n}\n\nexport function transition川FromPromise(promise) {\n  return Bacon.fromPromise(outcomeOfPromise(promise)).startWith(\n    loadingStateTransition()\n  )\n}\n\nexport function operationState川(transition川) {\n  return transition川.scan(INITIAL_OPERATION_STATE, transitionState)\n}\n","import axios from 'axios'\nimport invariant from 'invariant'\nimport { ScoreboardClient, ScoreboardRow } from './ScoreboardClient'\n\nexport interface CreateScoreboardClientOptions {\n  /**\n   * The URL of the scoreboard server.\n   */\n  server: string\n}\n\nexport function createNextScoreboardClient({\n  server,\n}: CreateScoreboardClientOptions): ScoreboardClient {\n  const client = axios.create({\n    baseURL: server,\n  })\n\n  async function getMyRecord(\n    playerToken: string,\n    md5: string,\n    playMode: string\n  ) {\n    const response = await client\n      .get(`/api/scoreboard/${md5}/${playMode}/mine`, {\n        headers: { Authorization: `Bearer ${playerToken}` },\n      })\n      .catch(handleAxiosError('Unable to retrieve personal records'))\n    return response.data.data as ScoreboardRow\n  }\n\n  const scoreboardClient: ScoreboardClient = {\n    async signUp({ username, password, email }) {\n      invariant(typeof username === 'string', 'username must be a string')\n      invariant(typeof password === 'string', 'password must be a string')\n      invariant(typeof email === 'string', 'email must be a string')\n      const response = await client\n        .post('/api/auth/signup', {\n          username,\n          password,\n          email,\n        })\n        .catch(handleAxiosError('Unable to sign up'))\n      return { playerToken: response.data.playerToken }\n    },\n    async loginByUsernamePassword({ username, password }) {\n      invariant(typeof username === 'string', 'username must be a string')\n      invariant(typeof password === 'string', 'password must be a string')\n      const response = await client\n        .post('/api/auth/login', {\n          username,\n          password,\n        })\n        .catch(handleAxiosError('Unable to log in'))\n      return { playerToken: response.data.playerToken }\n    },\n    async changePassword({ email }) {\n      await client\n        .post('/api/auth/reset', { email })\n        .catch(handleAxiosError('Unable to request password reset'))\n      return {}\n    },\n    async submitScore({ playerToken, md5, playMode, input }) {\n      await client\n        .post(\n          `/api/scoreboard/${md5}/${playMode}/submit`,\n          { scoreData: input },\n          { headers: { Authorization: `Bearer ${playerToken}` } }\n        )\n        .catch(handleAxiosError('Unable to submit score'))\n      return {\n        data: {\n          registerScore: {\n            resultingRow: await getMyRecord(playerToken, md5, playMode),\n          },\n        },\n      }\n    },\n    async retrieveScoreboard({ md5, playMode }) {\n      const response = await client\n        .get(`/api/scoreboard/${md5}/${playMode}/leaderboard`)\n        .catch(handleAxiosError('Unable to retrieve leaderboard'))\n      return {\n        data: {\n          chart: {\n            level: {\n              leaderboard: response.data.data,\n            },\n          },\n        },\n      }\n    },\n    async retrieveRecord({ playerToken, md5, playMode }) {\n      return {\n        data: {\n          chart: {\n            level: {\n              myRecord: await getMyRecord(playerToken, md5, playMode),\n            },\n          },\n        },\n      }\n    },\n    async retrieveRankingEntries({ playerToken, md5s }) {\n      const response = await client\n        .post(\n          `/api/scoreboard/records`,\n          { md5s },\n          { headers: { Authorization: `Bearer ${playerToken}` } }\n        )\n        .catch(handleAxiosError('Unable to retrieve ranking entries'))\n      return {\n        data: {\n          me: {\n            records: response.data.data,\n          },\n        },\n      }\n    },\n    async renewPlayerToken({ playerToken }) {\n      const response = await client\n        .post(\n          '/api/auth/renew',\n          {},\n          {\n            headers: { Authorization: `Bearer ${playerToken}` },\n          }\n        )\n        .catch(handleAxiosError('Unable to renew token'))\n      return response.data.playerToken\n    },\n  }\n\n  return scoreboardClient\n}\nfunction handleAxiosError(prefix: string) {\n  return (error: any): never => {\n    if (axios.isAxiosError(error)) {\n      const data = error.response?.data\n      const message = data?.message\n      const suffix = message ? `: ${message}` : ''\n      if (data) {\n        throw new Error(`${prefix}: ${error}${suffix}`)\n      }\n    }\n    throw error\n  }\n}\n","import ObjectID from 'bson-objectid'\nimport {\n  ScoreboardClient,\n  ScoreboardEntry,\n  ScoreboardRow,\n} from './ScoreboardClient'\nimport delay from 'delay'\n\ninterface Submission {\n  md5: string\n  playMode: string\n  entry: ScoreboardEntry\n}\n\nexport function createFakeScoreboardClient(): ScoreboardClient {\n  let submissions: Submission[] = []\n  const signedUpUsernames = new Set<string>()\n\n  const client: ScoreboardClient = {\n    signUp: async (options) => {\n      await delay(100)\n      if (signedUpUsernames.has(options.username)) {\n        throw new Error('Username already taken')\n      }\n      signedUpUsernames.add(options.username)\n      return { playerToken: 'FAKE!' + options.username }\n    },\n    loginByUsernamePassword: async (options) => {\n      await delay(100)\n      return { playerToken: 'FAKE!' + options.username }\n    },\n    changePassword: async (options) => {\n      return {}\n    },\n    renewPlayerToken: async (options) => {\n      return options.playerToken\n    },\n    submitScore: async (options) => {\n      await delay(100)\n      const { username } = decodeFakePlayerToken(options.playerToken)\n      const matching = (s: Submission): boolean =>\n        s.md5 === options.md5 &&\n        s.playMode === options.playMode &&\n        s.entry.player.name === username\n      const existingSubmission = submissions.find(matching)\n      const newScoreboardEntry = updateScoreboardEntry(\n        existingSubmission?.entry,\n        options.input,\n        { name: username }\n      )\n      submissions = submissions.filter((s) => !matching(s))\n      submissions.push({\n        md5: options.md5,\n        playMode: options.playMode,\n        entry: newScoreboardEntry,\n      })\n      return {\n        data: {\n          registerScore: {\n            resultingRow: getRow(options.md5, options.playMode, username)!,\n          },\n        },\n      }\n    },\n    retrieveRankingEntries: async (options) => {\n      await delay(100)\n      const { username } = decodeFakePlayerToken(options.playerToken)\n      const set = new Set<string>(options.md5s)\n      return {\n        data: {\n          me: {\n            records: submissions.filter(\n              (s) => set.has(s.md5) && s.entry.player.name === username\n            ),\n          },\n        },\n      }\n    },\n    retrieveRecord: async (options) => {\n      await delay(100)\n      const { username } = decodeFakePlayerToken(options.playerToken)\n      return {\n        data: {\n          chart: {\n            level: {\n              myRecord: getRow(options.md5, options.playMode, username),\n            },\n          },\n        },\n      }\n    },\n    retrieveScoreboard: async (options) => {\n      await delay(100)\n      return {\n        data: {\n          chart: {\n            level: {\n              leaderboard: getChartSubmissions(\n                options.md5,\n                options.playMode\n              ).map((s, i) => ({ rank: i + 1, entry: s.entry })),\n            },\n          },\n        },\n      }\n    },\n  }\n\n  function getRow(\n    md5: string,\n    playMode: string,\n    username: string\n  ): ScoreboardRow | null {\n    const chartSubmissions = getChartSubmissions(md5, playMode)\n    const mySubmission = chartSubmissions.find(\n      (s) => s.entry.player.name === username\n    )\n    if (!mySubmission) {\n      return null\n    }\n    const myRank =\n      chartSubmissions.filter((s) => s.entry.score > mySubmission.entry.score)\n        .length + 1\n    return {\n      rank: myRank,\n      entry: mySubmission.entry,\n    }\n  }\n\n  function getChartSubmissions(md5: string, playMode: string) {\n    return submissions\n      .filter((s) => s.md5 === md5 && s.playMode === playMode)\n      .sort((a, b) => b.entry.score - a.entry.score)\n  }\n\n  return client\n}\n\nfunction decodeFakePlayerToken(token: string) {\n  if (!token.startsWith('FAKE!')) {\n    throw new Error('Invalid player token: ' + token)\n  }\n  return { username: token.replace(/^FAKE!/, '') }\n}\n\nexport interface ScoreData {\n  score: number\n  combo: number\n  count: [number, number, number, number, number]\n  total: number\n  log: string\n}\n\nexport function updateScoreboardEntry(\n  original: ScoreboardEntry | null | undefined,\n  data: ScoreData,\n  player: { name: string }\n): ScoreboardEntry {\n  const nextPlayCount = (original?.playCount || 0) + 1\n  const score = +data.score\n  if (!original || score > original.score) {\n    return Object.assign({}, original || {}, {\n      id: original?.id || ObjectID.generate(),\n      score: score,\n      playCount: nextPlayCount,\n      playNumber: nextPlayCount,\n      combo: +data.combo || 0,\n      count: [\n        +data.count[0] || 0,\n        +data.count[1] || 0,\n        +data.count[2] || 0,\n        +data.count[3] || 0,\n        +data.count[4] || 0,\n      ] as [number, number, number, number, number],\n      total: +data.total || 0,\n      recordedAt: new Date().toJSON(),\n      player: player,\n    })\n  } else {\n    return Object.assign({}, original, {\n      playCount: nextPlayCount,\n    })\n  }\n}\n","import { createNextScoreboardClient } from './createNextScoreboardClient'\nimport { isTestModeEnabled } from 'bemuse/devtools/BemuseTestMode'\nimport { createFakeScoreboardClient } from './createFakeScoreboardClient'\n\nexport class OnlineService {\n  constructor({\n    fake = false,\n    server,\n    storagePrefix = fake ? 'fake-scoreboard.auth' : 'scoreboard.auth',\n    storage = localStorage,\n  }) {\n    this._isFake = fake\n    this._scoreboardClient = fake\n      ? createFakeScoreboardClient()\n      : createNextScoreboardClient({ server, log: () => {} })\n    this._storage = storage\n    this._storagePrefix = storagePrefix\n    this._updateUserFromStorage()\n    this._renewPlayerToken()\n  }\n\n  _updateUserFromStorage() {\n    const loadUser = (text) => {\n      if (!text) return null\n      try {\n        const data = JSON.parse(text)\n        const playerToken = data.playerToken\n        const playerTokenExpires = playerToken.startsWith('FAKE!')\n          ? Date.now() + 86400e3 * 7\n          : JSON.parse(atob(playerToken.split('.')[1])).exp * 1000\n        if (Date.now() > playerTokenExpires - 86400e3) {\n          console.warn('Authentication token is about to expire, skipping!')\n          return null\n        }\n        return data\n      } catch (e) {\n        return null\n      }\n    }\n    this._currentUser = loadUser(this._storage[`${this._storagePrefix}.id`])\n  }\n\n  _renewPlayerToken() {\n    const playerToken = this._currentUser && this._currentUser.playerToken\n    if (!playerToken) return\n    const username = this._currentUser.username\n    return this._scoreboardClient\n      .renewPlayerToken({ playerToken })\n      .then((newToken) => {\n        if (this._storage[`${this._storagePrefix}.id`]) {\n          this._storage[`${this._storagePrefix}.id`] = JSON.stringify({\n            username: username,\n            playerToken: newToken,\n          })\n        }\n      })\n  }\n\n  getCurrentUser() {\n    if (this._currentUser && this._currentUser.playerToken) {\n      return { username: this._currentUser.username }\n    } else {\n      return null\n    }\n  }\n\n  isLoggedIn() {\n    return !!this._currentUser\n  }\n\n  signUp({ username, password, email }) {\n    return this._scoreboardClient\n      .signUp({ username, password, email })\n      .then((signUpResult) => {\n        this._storage[`${this._storagePrefix}.id`] = JSON.stringify({\n          username: username,\n          playerToken: signUpResult.playerToken,\n        })\n        this._updateUserFromStorage()\n        return this.getCurrentUser()\n      })\n  }\n\n  logIn({ username, password }) {\n    return this._scoreboardClient\n      .loginByUsernamePassword({ username, password })\n      .then((loginResult) => {\n        this._storage[`${this._storagePrefix}.id`] = JSON.stringify({\n          username: username,\n          playerToken: loginResult.playerToken,\n        })\n        this._updateUserFromStorage()\n        return this.getCurrentUser()\n      })\n  }\n\n  changePassword({ email }) {\n    return this._scoreboardClient.changePassword({ email })\n  }\n\n  async logOut() {\n    delete this._storage[`${this._storagePrefix}.id`]\n    this._updateUserFromStorage()\n  }\n\n  async submitScore(info) {\n    if (isTestModeEnabled() && !this._isFake) {\n      throw new Error('Cannot submit score in test mode')\n    }\n    if (!this._currentUser) {\n      throw new Error('Not logged in')\n    }\n    const result = await this._scoreboardClient.submitScore({\n      playerToken: this._currentUser.playerToken,\n      md5: info.md5,\n      playMode: info.playMode,\n      input: {\n        score: info.score,\n        combo: info.combo,\n        count: info.count,\n        total: info.total,\n        log: info.log,\n      },\n    })\n    const data = {\n      md5: info.md5,\n      playMode: info.playMode,\n      ...toEntry(result.data.registerScore.resultingRow),\n    }\n    return data\n  }\n\n  // Retrieves a record.\n  //\n  // Returns a record object.\n  async retrieveRecord(level, user) {\n    const result = await this._scoreboardClient.retrieveRecord({\n      playerToken: this._currentUser.playerToken,\n      md5: level.md5,\n      playMode: level.playMode,\n    })\n    const myRecord = result.data.chart.level.myRecord\n    return (\n      myRecord && {\n        md5: level.md5,\n        playMode: level.playMode,\n        ...toEntry(myRecord),\n      }\n    )\n  }\n\n  // Retrieves the scoreboard\n  async retrieveScoreboard({ md5, playMode }) {\n    const result = await this._scoreboardClient.retrieveScoreboard({\n      md5,\n      playMode,\n    })\n    return { data: result.data.chart.level.leaderboard.map(toEntry) }\n  }\n\n  // Retrieve multiple records!\n  //\n  // Items is an array of song items. They have a md5 property.\n  async retrieveMultipleRecords(items) {\n    const result = await this._scoreboardClient.retrieveRankingEntries({\n      playerToken: this._currentUser.playerToken,\n      md5s: items.map((item) => item.md5),\n    })\n    const entries = result.data.me.records.map((item) => ({\n      ...toEntry(item),\n      md5: item.md5,\n      playMode: item.playMode,\n    }))\n    return entries\n  }\n}\n\nexport default OnlineService\n\nfunction toEntry(row) {\n  return {\n    rank: row.rank,\n    score: row.entry.score,\n    combo: row.entry.combo,\n    count: row.entry.count,\n    total: row.entry.total,\n    playerName: row.entry.player.name,\n    recordedAt: new Date(row.entry.recordedAt),\n    playCount: row.entry.playCount,\n    playNumber: row.entry.playNumber,\n  }\n}\n"],"names":["initialState","beginLoading","url","state","set","completeLoading","data","update","errorLoading","error","getCollectionByUrl","get","initLoading","status","initCompletedWithValue","value","isLoading","isCompleted","isError","completeWithValue","draft","errorWithReason","initWithText","text","staged","committed","searchText","inputText","handleTextType","handleDebounce","setText","selectedSongId","selectedChartId","selectedChartLevel","selectedSongGivenSongs","songs","song","id","selectedChartGivenCharts","charts","chart","file","Math","abs","getChartLevel","selectSong","songId","selectChart","chartId","chartLevel","info","level","difficulty","initWithDataFromStorage","options","toggleOptionEnabled","toggleOption","getKeyMapping","mode","key","changeKeyMapping","keyCode","playMode","changePlayMode","speed","changeSpeed","leadTime","parsed","parseInt","changeLeadTime","scratchPosition","changeScratchPosition","position","panelPlacement","changePanelPlacement","placement","laneCover","min","max","round","changeLaneCover","isBackgroundAnimationsEnabled","toggleBackgroundAnimations","isAutoVelocityEnabled","toggleAutoVelocity","isPreviewEnabled","togglePreview","isGaugeEnabled","getGauge","toggleGauge","keyboardMapping","mapping","control","hasAcknowledged","featureKey","acknowledge","audioInputLatency","changeAudioInputLatency","latency","isContinuousAxisEnabled","toggleContinuousAxis","sensitivity","changeSensitivity","lastSeenVersion","updateLastSeenVersion","newVersion","nextKeyToEdit","editing","scratch","keySet","index","indexOf","deltas","meticulousWindow","preciseWindow","sum","delta","difference","storage","localStorage","DEFAULTS","events","EventEmitter","getItem","setOptions","Object","keys","setItem","emit","getAllCurrentOptions","contains","haystack","needle","String","toLowerCase","filterText","filter","title","artist","genre","matches","handlers","action","type","COLLECTION_LOADING_BEGAN","COLLECTION_LOADING_ERRORED","COLLECTION_LOADED","CUSTOM_SONG_LOADED","CUSTOM_SONGS_LOADED","MUSIC_SEARCH_TEXT_TYPED","MUSIC_SEARCH_TEXT_INITIALIZED","MUSIC_SEARCH_DEBOUNCED","MUSIC_SONG_SELECTED","MUSIC_CHART_SELECTED","OPTIONS_LOADED_FROM_STORAGE","README_LOADING_STARTED","README_LOADED","README_LOADING_ERRORED","RAGEQUITTED","RAGEQUIT_DISMISSED","reducer","collections","createReducer","Collections","customSongLoadState","LoadState","customSongs","currentCollection","musicSearchText","MusicSearchText","musicSelection","MusicSelection","Options","currentSongReadme","rageQuit","selectCurrentCollectionUrl","selectCurrentCollection","selectIsCurrentCollectionLoading","selectCurrentCorrectionLoadError","selectCurrentCollectionValue","collection","preprocessCollection","selectSearchInputText","selectSearchText","selectGroups","selectSongs","selectSongListFromCurrentCollection","collectionData","selectSongList","songList","selectSortedSongList","sortSongs","selectFilteredSongList","selectSongOfTheDayEnabled","songOfTheDayEnabled","groupSongsIntoCategories","groups","map","flatten","selectSelectedSong","selectChartsForSelectedSong","selectSelectedChart","selectMusicSelection","getPlayableCharts","selectReadmeTextForSelectedSong","selectPlayMode","store","selectRageQuittedFlag","CustomFolderContextImpl","del","CUSTOM_FOLDER_KEYVAL_KEY","async","setCustomFolder","context","folder","handle","clearCustomFolder","getCustomFolderState","getDefaultCustomFolderContext","scanFolder","io","log","setStatus","updateState","i","result","scanIteration","nextState","moreIterationsNeeded","chartFilesScanned","inputState","message","permission","queryPermission","requestPermission","checkFolderStateAndPermissions","foldersToUpdate","length","n","songsToSave","updatedPathSet","Set","deadline","Date","now","entries","add","JSON","stringify","path","pathStr","formatPath","remaining","statusPrefix","resources","getResourcesForFolder","chartFiles","_unused","onMessage","push","songsToSavePathSet","newSongs","has","newFoldersToUpdate","updateFolders","foldersToRemove","remainingSongs","removedPathSet","includes","newFoldersToRemove","removeFolders","chartFileScanner","ChartFileScanner","searchForChartFiles","newChartFiles","getNewChartFiles","getFoldersToUpdate","getFoldersToRemove","getFolderCount","join","scanAllChartFiles","directoryHandle","parentPath","entriesRead","name","childPath","kind","test","fileHandle","addPath","getModifiedDate","getFile","lastModified","console","rootFolderHandle","folderHandle","getFolderHandleByPath","files","every","p","fileList","Promise","resolve","getFileHandle","getDirectoryHandle","constructor","previous","fast","foundFolderSet","updatedFolderSet","changedPaths","this","existingMap","Map","existingFolderSet","slice","folderKey","existing","parse","size","getSongsFromCustomFolders","customFolderSongs","resourceFactory","CustomFolderResourceFactory","out","customFolderSong","getResources","custom","e","getGrant","Error","getFolderHandle","loadSongFromResources","setLoggingFunction","then","read","Blob","loadFromBemuseSongJson","bmsFileList","all","filename","start","reject","worker","Worker","URL","onmessage","terminate","current","total","onerror","postMessage","bemusepack_url","loadFromBmsFileList","loadFromFileList","orderBy","getHashFunction","today","toISOString","split","md5","createHash","digest","SongOfTheDay","enabled","ids","sorted","s","tutorial","isSongOfTheDay","grouping","criteria","unreleased","added","sort","reverse","songOfTheDay","group","input","output","chart_names","subtitles","preprocessSong","bpm","CLEAR","INITIAL_STATE","scan","reduce","stateChanges","transition","performTransition","merge","put","putMultiple","transitions","clear","service","toProperty","user","getCurrentUser","submitScore","record","getScoreboard","retrieveScoreboard","bufferWithTime","seen","valueSeq","skipDuplicates","seq","toJS","flatMapLatest","toEventStream","delay","flatMap","levels","levelsToFetch","promise","retrieveMultipleRecords","results","loadedRecords","nullResults","catch","dispose","onValue","signUp","logIn","logOut","changePassword","scoreboard","Ranking","score","force","submissionModel","viewRecordModel","unauthenticatedRankingModel","model","self","meta","submission","resubmit","reloadScoreboard","retrieveRecord","INITIAL_OPERATION_STATE","loadingStateTransition","completedStateTransition","errorStateTransition","transitionState","previousState","assign","isWaiting","outcomeOfPromise","startWith","handleAxiosError","prefix","axios","response","suffix","createFakeScoreboardClient","submissions","signedUpUsernames","getRow","username","chartSubmissions","getChartSubmissions","mySubmission","find","entry","player","rank","a","b","playerToken","loginByUsernamePassword","renewPlayerToken","decodeFakePlayerToken","matching","existingSubmission","newScoreboardEntry","original","nextPlayCount","playCount","playNumber","combo","count","recordedAt","toJSON","updateScoreboardEntry","registerScore","resultingRow","retrieveRankingEntries","md5s","me","records","myRecord","leaderboard","token","startsWith","replace","fake","server","storagePrefix","_isFake","_scoreboardClient","client","baseURL","getMyRecord","headers","Authorization","password","email","post","scoreData","createNextScoreboardClient","_storage","_storagePrefix","_updateUserFromStorage","_renewPlayerToken","_currentUser","playerTokenExpires","atob","exp","warn","loadUser","newToken","isLoggedIn","signUpResult","loginResult","isTestModeEnabled","toEntry","items","item","row","playerName"],"sourceRoot":""}